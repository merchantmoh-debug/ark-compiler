// Standard Library: Math
// Fixed-Point Trigonometry (Scale: 10000)

func Tensor(data, shape) {
    return { data: data, shape: shape }
}

func matmul(a, b) {
    // a: Tensor { data: List, shape: [M, K] }
    // b: Tensor { data: List, shape: [K, N] }

    M := a.shape[0]
    K := a.shape[1]

    K2 := b.shape[0]
    N := b.shape[1]

    if K != K2 {
        print("Error: Matrix dimension mismatch in matmul")
        return Tensor([], [0,0])
    }

    res_data := []

    i := 0
    while i < M {
        j := 0
        while j < N {
            sum := 0
            k := 0
            while k < K {
                idx_a := i * K + k
                val_a := a.data[idx_a]

                idx_b := k * N + j
                val_b := b.data[idx_b]

                sum := sum + (val_a * val_b)
                k := k + 1
            }
            res_data := sys.list.append(res_data, sum)
            j := j + 1
        }
        i := i + 1
    }

    return Tensor(res_data, [M, N])
}

func transpose(t) {
    // t: Tensor { data: List, shape: [M, N] }
    M := t.shape[0]
    N := t.shape[1]

    res_data := []

    // Output shape will be [N, M]
    // We iterate in row-major order of the *output* matrix
    j := 0
    while j < N {
        i := 0
        while i < M {
            // Original value at (i, j)
            idx := i * N + j
            val := t.data[idx]
            res_data := sys.list.append(res_data, val)
            i := i + 1
        }
        j := j + 1
    }

    return Tensor(res_data, [N, M])
}

func dot(a, b) {
    // Vector dot product
    // Expects 1D tensors of same length
    len_a := len(a.data)
    len_b := len(b.data)

    if len_a != len_b {
        print("Error: Vector length mismatch in dot")
        return 0
    }

    sum := 0
    i := 0
    while i < len_a {
        val_a := a.data[i]
        val_b := b.data[i]
        sum := sum + (val_a * val_b)
        i := i + 1
    }
    return sum
}

func add(a, b) {
    // Element-wise addition
    len_a := len(a.data)
    len_b := len(b.data)

    if len_a != len_b {
        print("Error: Tensor size mismatch in add")
        return Tensor([], [0])
    }

    // Check shapes (simplified: just total size, but strictly should match shapes)
    // For now, assume consistent if sizes match

    res_data := []
    i := 0
    while i < len_a {
        val := a.data[i] + b.data[i]
        res_data := sys.list.append(res_data, val)
        i := i + 1
    }

    return Tensor(res_data, a.shape)
}

func sub(a, b) {
    // Element-wise subtraction
    len_a := len(a.data)
    len_b := len(b.data)

    if len_a != len_b {
        print("Error: Tensor size mismatch in sub")
        return Tensor([], [0])
    }

    res_data := []
    i := 0
    while i < len_a {
        val := a.data[i] - b.data[i]
        res_data := sys.list.append(res_data, val)
        i := i + 1
    }

    return Tensor(res_data, a.shape)
}

func mul_scalar(t, s) {
    // Multiply tensor t by scalar s
    len_t := len(t.data)

    res_data := []
    i := 0
    while i < len_t {
        val := t.data[i] * s
        res_data := sys.list.append(res_data, val)
        i := i + 1
    }

    return Tensor(res_data, t.shape)
}

math := {
    pi: 31415,
    sin: intrinsic_math_sin,
    cos: intrinsic_math_cos,
    tan: intrinsic_math_tan,
    asin: intrinsic_math_asin,
    acos: intrinsic_math_acos,
    atan: intrinsic_math_atan,
    atan2: intrinsic_math_atan2,
    pow: intrinsic_math_pow,
    sqrt: intrinsic_math_sqrt,
    Tensor: Tensor,
    matmul: matmul,
    transpose: transpose,
    dot: dot,
    add: add,
    sub: sub,
    mul_scalar: mul_scalar
}
