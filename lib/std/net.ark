// lib/std/net.ark

// --- HTTP Helpers ---
func http_get(url) {
    return sys.net.http.request("GET", url)
}

func http_post(url, body) {
    return sys.net.http.request("POST", url, body)
}

// --- Noise / Security Module ---

net_config := {
    ENABLE_NOISE: false
}
socket_secrets := {}

func noise_handshake(handle) {
    if net_config.ENABLE_NOISE == false {
        return true
    }

    print("[Noise] Handshake Initiated for handle " + handle)

    // 1. Generate Ephemeral Keys
    keys := sys.crypto.ed25519.gen()
    priv := keys[0]
    pub := keys[1]

    // 2. Exchange Keys
    // Send my Pub
    sys.net.socket.send(handle, pub)

    // Recv Peer Pub (expecting 64 chars hex)
    // We might need to handle timeout/blocking here carefully.
    // For now, assume blocking recv is fine for handshake.
    peer_pub := sys.net.socket.recv(handle, 64)

    if peer_pub == false {
         print("[Noise] Handshake Failed: Timeout or Error receiving peer key")
         return false
    }

    len_peer_res := sys.len(peer_pub)
    len_peer := len_peer_res[0]
    if len_peer != 64 {
        print("[Noise] Handshake Failed: Invalid Peer Key Length: " + len_peer)
        return false
    }

    // 3. Derive Shared Secret (Mock: Hash of sorted keys)
    combined := ""
    if pub < peer_pub {
        combined := pub + peer_pub
    } else {
        combined := peer_pub + pub
    }
    secret := sys.crypto.hash(combined)

    // 4. Store Secret
    // Key must be string for struct
    key_str := "" + handle
    sys.struct.set(socket_secrets, key_str, secret)

    print("[Noise] Handshake Success. Secret established.")
    return true
}

func secure_send(handle, data) {
    // Check if secure
    if net_config.ENABLE_NOISE {
        key_str := "" + handle
        if sys.struct.has(socket_secrets, key_str) {
            // Handshake done, secure channel established
        }
    }
    return sys.net.socket.send(handle, data)
}

func secure_recv(handle, size) {
    return sys.net.socket.recv(handle, size)
}

// --- Socket Module ---
socket := {
    bind: sys.net.socket.bind,
    accept: sys.net.socket.accept,
    connect: sys.net.socket.connect,
    send: secure_send,
    recv: secure_recv,
    close: sys.net.socket.close,
    set_timeout: sys.net.socket.set_timeout
}

// --- P2P Network Logic ---

// Global Peers List
peers := []

func net_connect(ip, port) {
    // 1. Connect
    handle := sys.net.socket.connect(ip, port)

    // 1.5 Noise Handshake
    if net_config.ENABLE_NOISE {
        if noise_handshake(handle) == false {
             print("[Net] Handshake failed, closing connection.")
             sys.net.socket.close(handle)
             return -1
        }
    }

    // 2. Handshake (App Layer)
    secure_send(handle, "HELLOv1")

    // 2.5 Set Timeout (non-blocking feel)
    sys.net.socket.set_timeout(handle, 100)

    // 3. Register Peer
    peer := {
        ip: ip,
        port: port,
        last_seen: sys.time.now(),
        socket: handle
    }
    sys.list.append(peers, peer)
    print("[Net] Connected to " + ip + ":" + port)
    return handle
}

func net_broadcast(msg) {
    i := 0
    len_peers := len(peers)
    while i < len_peers {
        p := peers[i]
        // TODO: Handle disconnected peers
        sys.net.socket.send(p.socket, msg)
        i := i + 1
    }
}

func net_listen(port) {
    server := sys.net.socket.bind(port)
    sys.net.socket.set_timeout(server, 100)

    print("[Net] Listening on port " + port)

    while true {
        // 1. Accept New Connections
        res := sys.net.socket.accept(server)
        if res {
            // res is [handle, ip]
            client := res[0]
            ip := res[1]
            print("[Net] Accepted connection from " + ip)

            // Handshake (Server Side)
            handshake_ok := true
            if net_config.ENABLE_NOISE {
                // Set timeout for handshake
                sys.net.socket.set_timeout(client, 2000)
                if noise_handshake(client) == false {
                    print("[Net] Handshake failed from " + ip)
                    sys.net.socket.close(client)
                    handshake_ok := false
                }
            }

            if handshake_ok {
                // Set short timeout for non-blocking feel
                sys.net.socket.set_timeout(client, 0)

                peer := {
                    ip: ip,
                    port: 0, // Unknown remote port? We have IP.
                    last_seen: sys.time.now(),
                    socket: client
                }
                sys.list.append(peers, peer)
            }
        }

        // 2. Poll Existing Peers
        i := 0
        while i < len(peers) {
            p := peers[i]
            msg := sys.net.socket.recv(p.socket, 1024)

            if msg != false {
                if msg == "" {
                    // EOF / Closed
                    print("[Net] Peer " + p.ip + " disconnected")
                    sys.net.socket.close(p.socket)
                    sys.list.pop(peers, i)
                    // Don't increment i, next item shifted to i
                } else {
                    p.last_seen := sys.time.now()
                    print("[Net] Recv from " + p.ip + ": " + msg)
                    // TODO: Dispatch message handler
                    i := i + 1
                }
            } else {
                i := i + 1
            }
        }
    }
}

// --- HTTP Module ---
http := {
    serve: sys.net.http.serve,
    request: sys.net.http.request,
    get: http_get,
    post: http_post
}

// --- Net Module Export ---
net := {
    http: http,
    socket: socket,
    config: net_config,

    // P2P
    connect: net_connect,
    listen: net_listen,
    broadcast: net_broadcast,
    peers: peers
}
