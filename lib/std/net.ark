// lib/std/net.ark

// --- HTTP Helpers ---
func http_get(url) {
    return sys.net.http.request("GET", url)
}

func http_post(url, body) {
    return sys.net.http.request("POST", url, body)
}

// --- Socket Module ---
socket := {
    bind: sys.net.socket.bind,
    accept: sys.net.socket.accept,
    connect: sys.net.socket.connect,
    send: sys.net.socket.send,
    recv: sys.net.socket.recv,
    close: sys.net.socket.close,
    set_timeout: sys.net.socket.set_timeout
}

// --- P2P Network Logic ---

// Global Peers List
peers := []

func net_connect(ip, port) {
    // 1. Connect
    handle := sys.net.socket.connect(ip, port)

    // 2. Handshake
    sys.net.socket.send(handle, "HELLOv1")

    // 2.5 Set Timeout (non-blocking feel)
    sys.net.socket.set_timeout(handle, 100)

    // 3. Register Peer
    peer := {
        ip: ip,
        port: port,
        last_seen: sys.time.now(),
        socket: handle
    }
    sys.list.append(peers, peer)
    print("[Net] Connected to " + ip + ":" + port)
    return handle
}

func net_broadcast(msg) {
    i := 0
    len_peers := len(peers)
    while i < len_peers {
        p := peers[i]
        // TODO: Handle disconnected peers
        sys.net.socket.send(p.socket, msg)
        i := i + 1
    }
}

func net_listen(port) {
    server := sys.net.socket.bind(port)
    sys.net.socket.set_timeout(server, 100)

    print("[Net] Listening on port " + port)

    while true {
        // 1. Accept New Connections
        res := sys.net.socket.accept(server)
        if res {
            // res is [handle, ip]
            client := res[0]
            ip := res[1]
            print("[Net] Accepted connection from " + ip)

            // Set short timeout for non-blocking feel
            sys.net.socket.set_timeout(client, 0)

            peer := {
                ip: ip,
                port: 0, // Unknown remote port? We have IP.
                last_seen: sys.time.now(),
                socket: client
            }
            sys.list.append(peers, peer)
        }

        // 2. Poll Existing Peers
        i := 0
        while i < len(peers) {
            p := peers[i]
            msg := sys.net.socket.recv(p.socket, 1024)

            if msg != false {
                if msg == "" {
                    // EOF / Closed
                    print("[Net] Peer " + p.ip + " disconnected")
                    sys.net.socket.close(p.socket)
                    sys.list.pop(peers, i)
                    // Don't increment i, next item shifted to i
                } else {
                    p.last_seen := sys.time.now()
                    print("[Net] Recv from " + p.ip + ": " + msg)
                    // TODO: Dispatch message handler
                    i := i + 1
                }
            } else {
                i := i + 1
            }
        }
    }
}

// --- HTTP Module ---
http := {
    serve: sys.net.http.serve,
    request: sys.net.http.request,
    get: http_get,
    post: http_post
}

// --- Net Module Export ---
net := {
    http: http,
    socket: socket,

    // P2P
    connect: net_connect,
    listen: net_listen,
    broadcast: net_broadcast,
    peers: peers
}
