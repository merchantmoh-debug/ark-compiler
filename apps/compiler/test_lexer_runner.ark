
// The Architect: Functional Lexer Implementation & Test Runner
// Objective: Convert source string into a list of Tokens using Structs.

// --- Constants ---
// Token Types
TOKEN_EOF := 0
TOKEN_IDENTIFIER := 1
TOKEN_NUMBER := 2
TOKEN_STRING := 3
TOKEN_SYMBOL := 4
TOKEN_KEYWORD := 5

// --- Helpers ---

func is_digit(char_str) {
    return (char_str >= "0") && (char_str <= "9")
}

func is_alpha(char_str) {
    return ((char_str >= "a") && (char_str <= "z")) || ((char_str >= "A") && (char_str <= "Z")) || (char_str == "_")
}

func is_whitespace(char_str) {
    return (char_str == " ") || (char_str == "\n") || (char_str == "\t") || (char_str == "\r")
}

// --- Lexer Struct & Methods ---

func lexer_new(source) {
    let (l, src) := sys.len(source)
    return {
        source: src,
        length: l,
        pos: 0,
        line: 1,
        col: 1,
        tokens: [],
        token_count: 0
    }
}

func lexer_peek(lexer) {
    if lexer.pos >= lexer.length {
        return "" // EOF
    }
    // Uses polymorphic sys.list.get via operator[]
    return lexer.source[lexer.pos]
}

func lexer_advance(lexer) {
    c := lexer_peek(lexer)
    lexer.pos := lexer.pos + 1
    if c == "\n" {
        lexer.line := lexer.line + 1
        lexer.col := 1
    } else {
        lexer.col := lexer.col + 1
    }
    return lexer
}

func lexer_add_token(lexer, type, value) {
    token := {
        type: type,
        value: value,
        line: lexer.line,
        col: lexer.col
    }

    lexer.tokens := sys.list.append(lexer.tokens, token)
    lexer.token_count := lexer.token_count + 1
    return lexer
}

func lexer_scan(lexer) {
    // Main loop
    char_str := lexer_peek(lexer)
    
    if char_str == "" {
        lexer := lexer_add_token(lexer, TOKEN_EOF, "EOF")
        return lexer
    }
    
    if is_whitespace(char_str) {
        lexer := lexer_advance(lexer)
        return lexer_scan(lexer) // Tail recursion simulation (manual recursion)
    }
    
    if is_digit(char_str) {
        // Parse number
        num_str := ""
        // While loop condition needs careful handling of peek
        // In Ark, while condition is expression.
        // We need a helper to check safely without advancing or errors?
        // simple while loop:
        
        looping := true
        while looping {
             c := lexer_peek(lexer)
             if is_digit(c) {
                 num_str := num_str + c
                 lexer := lexer_advance(lexer)
             } else {
                 looping := false
             }
        }
        lexer := lexer_add_token(lexer, TOKEN_NUMBER, num_str)
        return lexer
    }
    
    if is_alpha(char_str) {
        // Parse identifier/keyword
        ident_str := ""
        looping := true
        while looping {
             c := lexer_peek(lexer)
             if is_alpha(c) || is_digit(c) {
                 ident_str := ident_str + c
                 lexer := lexer_advance(lexer)
             } else {
                 looping := false
             }
        }
        // Todo: Check keywords (func, let, if, etc)
        // simple keyword check
        type := TOKEN_IDENTIFIER
        if ident_str == "func" { type := TOKEN_KEYWORD }
        if ident_str == "let" { type := TOKEN_KEYWORD }
        if ident_str == "if" { type := TOKEN_KEYWORD }
        if ident_str == "else" { type := TOKEN_KEYWORD }
        if ident_str == "while" { type := TOKEN_KEYWORD }
        if ident_str == "return" { type := TOKEN_KEYWORD }
        if ident_str == "class" { type := TOKEN_KEYWORD }
        if ident_str == "true" { type := TOKEN_KEYWORD }
        if ident_str == "false" { type := TOKEN_KEYWORD }
        if ident_str == "and" { type := TOKEN_KEYWORD }
        if ident_str == "or" { type := TOKEN_KEYWORD }

        lexer := lexer_add_token(lexer, type, ident_str)
        return lexer
    }
    
    // Symbols (single char for now)
    // Handle := (2 chars)
    if char_str == ":" {
         // Check next
         // Peek next char requires lookahead logic not in `peek`.
         // `source[pos+1]`
         next_char := ""
         if (lexer.pos + 1) < lexer.length {
             next_char := lexer.source[lexer.pos + 1]
         }
         
         if next_char == "=" {
             lexer := lexer_add_token(lexer, TOKEN_SYMBOL, ":=")
             lexer := lexer_advance(lexer)
             lexer := lexer_advance(lexer)
             return lexer
         }
    }

    lexer := lexer_add_token(lexer, TOKEN_SYMBOL, char_str)
    lexer := lexer_advance(lexer)
    return lexer
}

func lexer_tokenize(source) {
    lexer := lexer_new(source)
    running := true
    while running {

        count := lexer.token_count

        if count > 0 {
            // Extract from struct (consumes field)
            toks := lexer.tokens
            
            // Get item (consumes list, returns [val, new_list])
            // (token_struct, toks) := toks[count - 1] -> Syntax supported?
            // "let (a, b) := ..." 
            
            let (last_token_pair, toks) := sys.list.get(toks, count - 1)
            // Wait, sys.list.get returns [val, list]
            // But 'val' might be token struct.
            // Oh, I can just destructure the result of get.
            // let (token_struct, toks) := toks[count - 1]
            // But toks[index] syntactic sugar might not work with let destructure if parser isn't smart enough?
            // Let's use direct intrinsic call or explicit step.
            
            full_res := toks[count - 1]
            let (token_struct, toks) := full_res
            
            // Put back
            lexer.tokens := toks
            
            type := token_struct.type
            if type == TOKEN_EOF {
                running := false
            } else {
                lexer := lexer_scan(lexer)
            }
        } else {
            lexer := lexer_scan(lexer)
        }
    }
    return lexer.tokens
}

// --- TEST RUNNER ---

src := "func let if else while return class true false and or"
// print("Source:", src)
print("Source: " + src)

tokens := lexer_tokenize(src)
print("Tokens Generated:")

// Print tokens pretty
let (cnt, toks) := sys.len(tokens)
tokens := toks
count := cnt
i := 0
while i < count {
    // let (tok, _) := tokens[i]
    let (tok, _ign) := tokens[i]
    print("Token:", tok)
    i := i + 1
}
