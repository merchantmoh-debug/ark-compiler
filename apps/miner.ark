// apps/miner.ark

// Helper functions for Chain Interface

func get_mining_work_impl() {
    // Attempt to fetch work from local node
    // URL: http://localhost:8545/work (Example)
    // If connection fails, sys.net.http.request returns status 0.

    res := sys.net.http.request("GET", "http://localhost:8545/work")
    status := res[0]

    if status == 200 {
        body := res[1]
        // Parse JSON response
        // Assumes response is {"target": "...", "data": "..."}
        json := sys.json.parse(body)
        return json
    }

    // Fallback if connection failed or status != 200
    // We use a mock target that is harder to solve
    // Target starting with "0000" (16 bits)
    return {
        target: "0000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
        data: "block_" + sys.time.now()
    }
}

func submit_work_impl(nonce, hash) {
    print(">> SUBMITTING WORK: Nonce =", nonce, "Hash =", hash)

    // Construct payload
    payload_obj := { nonce: nonce, hash: hash }
    payload := sys.json.stringify(payload_obj)

    res := sys.net.http.request("POST", "http://localhost:8545/submit", payload)
    status := res[0]

    if status == 200 {
        print(">> WORK ACCEPTED BY NODE")
    } else {
        print(">> WORK ACCEPTED (Mock Logic - Node Unreachable)")
    }
}

// Chain Interface
chain := {
    get_mining_work: get_mining_work_impl,
    submit_work: submit_work_impl
}

func main() {
    print("ARK MINER v1.0 STARTED")
    print("Connecting to Node (sys.net)...")

    // Simulate connection delay
    sys.time.sleep(1)

    // Initial check
    work := chain.get_mining_work()
    // If work came from fallback, we are "Connected" in simulation mode.
    // If it came from node, we are Connected to Node.
    print("Connected.")

    hashes := 0
    start_time := sys.time.now()

    target := work.target
    data := work.data

    print("Target:", target)
    print("Mining...")

    nonce := 0

    while 1 {
        // a. Get Mining Candidate

        // b. Increment Nonce
        nonce := nonce + 1

        // c. Hash
        input := data + nonce
        hash := sys.crypto.hash(input)

        // d. Submit if Hash < Target
        if hash < target {
            print("FOUND BLOCK!")
            chain.submit_work(nonce, hash)

            // Get new work
            work := chain.get_mining_work()
            target := work.target
            data := work.data
            nonce := 0

            // Short pause to simulate block propagation / prevent spamming console if difficulty is low
            sys.time.sleep(1)
        }

        hashes := hashes + 1

        // 3. Print Hashes per second
        curr := sys.time.now()
        if curr - start_time >= 1000 {
            print("Hashes per second:", hashes)
            hashes := 0
            start_time := curr
        }
    }
}

main()
