// --- LSP Main ---

func int_to_str(i) {
    return "" + i
}

func print(msg) {
    sys.log(msg)
}

func read_header() {
    content_len := 0
    running := true
    while running {
        line := sys.io.read_line()
        if line == "" { return -1 }
        if (line == "\r\n") || (line == "\n") {
            running := false
        } else {
             match := true
             prefix := "Content-Length:"
             
             let (len_line, _) := sys.len(line)
             if len_line < 15 {
                 match := false
             } else {
                 i := 0
                 while i < 15 {
                     let (c, _) := sys.str.get(line, i)
                     let (p, _) := sys.str.get(prefix, i)
                     if c != p { match := false }
                     i := i + 1
                 }
             }

             if match {
                 j := 15
                 let (c, _) := sys.str.get(line, j)
                 if c == " " { j := j + 1 }

                 num_str := ""
                 collecting := true
                 while collecting {
                     let (c, _) := sys.str.get(line, j)
                     if (c >= "0") && (c <= "9") {
                         num_str := num_str + c
                         j := j + 1
                     } else {
                         collecting := false
                     }
                 }
                 if num_str != "" {
                     content_len := sys.json.parse(num_str)
                 }
             }
        }
    }
    return content_len
}

func handle_message(msg) {
    has_method := sys.struct.has(msg, "method")
    if has_method == false { return 0 }

    let (method, _) := sys.struct.get(msg, "method")
    sys.log("Method: " + method)

    if method == "initialize" {
        has_id := sys.struct.has(msg, "id")
        if has_id {
            let (id, _) := sys.struct.get(msg, "id")
            res := {
                capabilities: {
                    textDocumentSync: 1
                }
            }
            send_response(id, res)
        }
    } else if method == "shutdown" {
        has_id := sys.struct.has(msg, "id")
        if has_id {
            let (id, _) := sys.struct.get(msg, "id")
            // Send null (Unit) as result
            // Ark Unit is passed as None to python json parser?
            // Yes, from_ark returns None for Unit.
            // But we can't create literal Unit easily in Ark source except from void function.
            // Or pass a variable that is Unit.
            // Let's pass a string "null" and rely on client? No, must be null.
            // I'll create a helper `get_null()`?
            // Or just `{}` and client ignores?
            // `sys.json.parse("null")` returns Unit.
            null_val := sys.json.parse("null")
            send_response(id, null_val)
        }
    } else if method == "exit" {
        sys.exit(0)
    } else if method == "textDocument/didOpen" {
        let (params, _) := sys.struct.get(msg, "params")
        let (doc, _) := sys.struct.get(params, "textDocument")
        let (uri, _) := sys.struct.get(doc, "uri")
        let (text, _) := sys.struct.get(doc, "text")
        validate(uri, text)
    } else if method == "textDocument/didChange" {
        let (params, _) := sys.struct.get(msg, "params")
        let (doc, _) := sys.struct.get(params, "textDocument")
        let (uri, _) := sys.struct.get(doc, "uri")
        let (changes, _) := sys.struct.get(params, "contentChanges")
        let (first, _) := sys.list.get(changes, 0)
        let (text, _) := sys.struct.get(first, "text")
        validate(uri, text)
    }
}

func validate(uri, text) {
    sys.log("Validating: " + uri)

    tokens := lexer_tokenize(text)
    ast := parse_program(tokens)

    errors := []
    collect_errors(ast, errors)

    send_notification("textDocument/publishDiagnostics", {
        uri: uri,
        diagnostics: errors
    })
}

func collect_errors(node, errors) {
    has_kind := sys.struct.has(node, "kind")
    if has_kind == false { return 0 }

    let (kind, _) := sys.struct.get(node, "kind")

    if kind == 99 {
        let (msg, _) := sys.struct.get(node, "value")
        let (line, _) := sys.struct.get(node, "line")
        let (col, _) := sys.struct.get(node, "col")

        l := line - 1
        c := col - 1

        diag := {
            range: {
                start: { line: l, character: c },
                end: { line: l, character: c + 1 }
            },
            severity: 1,
            message: "Syntax Error: " + msg,
            source: "ark-lsp"
        }
        sys.list.append(errors, diag)
        return 0
    }

    traverse_list(node, "children", errors)
    traverse_list(node, "body", errors)
    traverse_list(node, "then_block", errors)
    traverse_list(node, "else_block", errors)

    traverse_node(node, "expression", errors)
    traverse_node(node, "condition", errors)
    traverse_node(node, "left", errors)
    traverse_node(node, "right", errors)
    traverse_node(node, "value", errors)
}

func traverse_list(parent, field, errors) {
    if sys.struct.has(parent, field) {
        let (lst, _) := sys.struct.get(parent, field)
        // Check if list via sys.len
        // If it fails, catch? No catch.
        // We assume schema correctness.
        // Or check type via intrinsic? No typeof.
        // But field "children" is always list in parser.

        // Safety: If field exists, assume it is list for these fields.
        let (len, _) := sys.len(lst)
        i := 0
        while i < len {
            let (child, _) := sys.list.get(lst, i)
            collect_errors(child, errors)
            i := i + 1
        }
    }
}

func traverse_node(parent, field, errors) {
    if sys.struct.has(parent, field) {
        let (child, _) := sys.struct.get(parent, field)
        collect_errors(child, errors)
    }
}

func send_response(id, result) {
    obj := {
        jsonrpc: "2.0",
        id: id,
        result: result
    }
    send_json(obj)
}

func send_notification(method, params) {
    obj := {
        jsonrpc: "2.0",
        method: method,
        params: params
    }
    send_json(obj)
}

func send_json(obj) {
    body := sys.json.stringify(obj)
    let (l, _) := sys.len(body)
    header := "Content-Length: " + int_to_str(l) + "\r\n\r\n"
    sys.io.write(header + body)
}

func main() {
    sys.log("Ark LSP Started")
    while true {
        len := read_header()
        if len == -1 { sys.exit(0) }
        if len > 0 {
            body := sys.io.read_bytes(len)
            msg := sys.json.parse(body)
            handle_message(msg)
        }
    }
}

main()
