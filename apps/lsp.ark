
// --- Preamble ---
func print(msg) {
    sys.log(msg)
}

func int_to_str(i) {
    return "" + i
}

true := 1 == 1
false := 1 == 0


// The Architect: Functional Lexer Implementation
// Objective: Convert source string into a list of Tokens using Structs.

// --- Constants ---
// Token Types
TOKEN_EOF := 0
TOKEN_IDENTIFIER := 1
TOKEN_NUMBER := 2
TOKEN_STRING := 3
TOKEN_SYMBOL := 4
TOKEN_KEYWORD := 5

// Keywords (Must match Parser)
TOKEN_KEYWORD_IF := 100
TOKEN_KEYWORD_ELSE := 101
TOKEN_KEYWORD_WHILE := 102
TOKEN_KEYWORD_FUNC := 103
TOKEN_KEYWORD_RETURN := 104
TOKEN_KEYWORD_LET := 105

// --- Helpers ---

func is_digit(char_str) {
    return (char_str >= "0") and (char_str <= "9")
}

func is_alpha(char_str) {
    return ((char_str >= "a") and (char_str <= "z")) or ((char_str >= "A") and (char_str <= "Z")) or (char_str == "_")
}

func is_whitespace(char_str) {
    return (char_str == " ") or (char_str == "\n") or (char_str == "\t") or (char_str == "\r")
}

// --- Lexer Struct & Methods ---

func lexer_new(source) {
    let (l, src) := sys.len(source)
    return {
        source: src,
        length: l,
        pos: 0,
        line: 1,
        col: 1,
        tokens: []
    }
}

func lexer_peek(lexer) {
    if lexer.pos >= lexer.length {
        return "" // EOF
    }
    let (c, src) := sys.str.get(lexer.source, lexer.pos)
    return c
}

func lexer_advance(lexer) {
    c := lexer_peek(lexer)
    lexer.pos := lexer.pos + 1
    if c == "\n" {
        lexer.line := lexer.line + 1
        lexer.col := 1
    } else {
        lexer.col := lexer.col + 1
    }
    // Return modified lexer because we modified fields in place?
    // `lexer.pos := ...` updates the Struct in place (Rust `eval.rs` SetField).
    return lexer
}

func lexer_add_token(lexer, type, value) {
    token := {
        type: type,
        value: value,
        line: lexer.line,
        col: lexer.col
    }
    lexer.tokens := sys.list.append(lexer.tokens, token)
    return lexer
}

func check_keyword(ident_str) {
    if ident_str == "if" { return 100 }
    if ident_str == "else" { return 101 }
    if ident_str == "while" { return 102 }
    if ident_str == "func" { return 103 }
    if ident_str == "return" { return 104 }
    if ident_str == "let" { return 105 }
    return 1 // TOKEN_IDENTIFIER
}

func lexer_scan(lexer) {
    // Main loop
    char_str := lexer_peek(lexer)

    if char_str == "" {
        lexer := lexer_add_token(lexer, TOKEN_EOF, "EOF")
        return lexer
    }

    if is_whitespace(char_str) {
        lexer := lexer_advance(lexer)
        return lexer_scan(lexer) // Tail recursion? We don't have TCO. Loop in evaluator.
        // Wait, Ark doesn't have loops in functions yet?
        // It has `while` statement.
        // So `lexer_scan` should be called in a loop in `main`.
    }

    if is_digit(char_str) {
        // Parse number
        num_str := ""
        while is_digit(lexer_peek(lexer)) {
            num_str := num_str + lexer_peek(lexer)
            lexer := lexer_advance(lexer)
        }
        lexer := lexer_add_token(lexer, TOKEN_NUMBER, num_str)
        return lexer
    }


    if is_alpha(char_str) {
        // Parse identifier/keyword
        ident_str := ""
        while is_alpha(lexer_peek(lexer)) or is_digit(lexer_peek(lexer)) {
            ident_str := ident_str + lexer_peek(lexer)
            lexer := lexer_advance(lexer)
        }

        token_type := check_keyword(ident_str)
        lexer := lexer_add_token(lexer, token_type, ident_str)
        return lexer
    }

    // Comments
    if char_str == "/" {
        if (lexer.pos + 1) < lexer.length {
            let (next_char, _src) := sys.str.get(lexer.source, lexer.pos + 1)
            if next_char == "/" {
                 // Skip until newline
                 looping := true
                 while looping {
                     lexer := lexer_advance(lexer)
                     c := lexer_peek(lexer)
                     if c == "\n" {
                         looping := false
                     }
                     if c == "" {
                         looping := false
                     }
                 }
                 return lexer_scan(lexer)
            }
        }
    }

    // Symbols
    lexer := lexer_add_token(lexer, TOKEN_SYMBOL, char_str)
    lexer := lexer_advance(lexer)
    return lexer
}

func lexer_tokenize(source) {
    lexer := lexer_new(source)
    running := true
    while running {
        let (count, tokens_ref) := sys.len(lexer.tokens)
        lexer.tokens := tokens_ref
        if count > 0 {
            last_token := sys.list.get(lexer.tokens, count - 1)
            let (token_val, token_list) := last_token
            type := token_val.type
            if type == TOKEN_EOF {
                running := false
            } else {
                lexer := lexer_scan(lexer)
            }
        } else {
            lexer := lexer_scan(lexer)
        }
    }
    return lexer.tokens
}

// --- Ark Parser (Self-Hosted) ---

// --- Token Types (Must Match Lexer) ---
TOKEN_EOF := 0
TOKEN_IDENTIFIER := 1
TOKEN_NUMBER := 2
TOKEN_STRING := 3
TOKEN_EQ := 4         // =
TOKEN_PLUS := 5       // +
TOKEN_MINUS := 6      // -
TOKEN_STAR := 7       // *
TOKEN_SLASH := 8      // /
TOKEN_LPAREN := 9     // (
TOKEN_RPAREN := 10    // )
TOKEN_LBRACE := 11    // {
TOKEN_RBRACE := 12    // }
TOKEN_COMMA := 13     // ,
TOKEN_COLON := 14     // :
TOKEN_SEMICOLON := 15 // ;
TOKEN_ASSIGN := 16    // :=
TOKEN_GT := 17        // >
TOKEN_LT := 18        // <
TOKEN_GE := 19        // >=
TOKEN_LE := 20        // <=
TOKEN_EQ_EQ := 21     // ==
TOKEN_NOT_EQ := 22    // !=
TOKEN_AND := 23       // &&
TOKEN_OR := 24        // ||
TOKEN_KEYWORD_IF := 100
TOKEN_KEYWORD_ELSE := 101
TOKEN_KEYWORD_WHILE := 102
TOKEN_KEYWORD_FUNC := 103
TOKEN_KEYWORD_RETURN := 104
TOKEN_KEYWORD_LET := 105

// --- AST Node Types ---
NODE_PROGRAM := 0
NODE_FUNC_DEF := 1
NODE_BLOCK := 2
NODE_IF := 3
NODE_WHILE := 4
NODE_RETURN := 5
NODE_LET := 6
NODE_ASSIGN := 101 // Matching test runner
NODE_EXPR_BINARY := 8
NODE_EXPR_CALL := 9
NODE_EXPR_LITERAL_INT := 10
NODE_EXPR_LITERAL_STR := 11
NODE_EXPR_VAR := 12
NODE_EXPR_LITERAL_BOOL := 13

// --- Parser State ---
func parser_new(tok_input) {
    return {
        tokens: tok_input,
        pos: 0
    }
}

func parser_peek(parser) {
    // parser is Linear. We must use sys.struct.get to peek fields.
    // get tokens
    let (tok_list, parser) := sys.struct.get(parser, "tokens")

    // get pos
    let (pos, parser) := sys.struct.get(parser, "pos")

    // Attempt to get token
    // We rely on EOF token being present.
    let (tok, tok_list) := sys.list.get(tok_list, pos)

    // Restore tokens
    parser := sys.struct.set(parser, "tokens", tok_list)

    return [tok, parser]
}

func parser_advance(parser) {
    // Read pos
    let (pos, parser) := sys.struct.get(parser, "pos")

    // Update
    new_pos := pos + 1

    // Set
    parser := sys.struct.set(parser, "pos", new_pos)
    return parser
}

func parse_primary(parser) {
    let (tok, p_peek) := parser_peek(parser)
    let (ttype, tok) := sys.struct.get(tok, "type")

    // TOKEN_NUMBER := 2
    if ttype == 2 {
        let (val, tok) := sys.struct.get(tok, "value")
        p_adv := parser_advance(p_peek)
        node := { kind: NODE_EXPR_LITERAL_INT, value: val }
        return [node, p_adv]
    }

    // TOKEN_IDENTIFIER := 1
    if ttype == 1 {
        let (val, tok) := sys.struct.get(tok, "value")
        p_after_id := parser_advance(p_peek)

        // Check for Call: Identifier + LPAREN
        let (tok2, p_peek2) := parser_peek(p_after_id)
        let (ttype2, tok2) := sys.struct.get(tok2, "type")

        // TOKEN_LPAREN := 9
        if ttype2 == 9 {
             p_after_paren := parser_advance(p_peek2)

             // Parse Args
             args := []
             ref_parser := [p_after_paren]
             running := true

             while running {
                 let (p, _) := sys.list.get(ref_parser, 0)
                 let (t, p_pk) := parser_peek(p)
                 let (tt, t) := sys.struct.get(t, "type")

                 // TOKEN_RPAREN := 10
                 if tt == 10 {
                     running := false
                     p_after_args := parser_advance(p_pk)
                     ref_parser := [p_after_args]
                 } else {
                     // Check if not first arg (comma?) - Simplified: parse expr, then check comma
                     // For now: Expr, optional comma
                     let (arg_expr, p_next) := parse_expr(p_pk)  // Use p_pk
                     args := sys.list.append(args, arg_expr)

                     // Check Comma or RPAREN
                     let (t2, p_pk2) := parser_peek(p_next)
                     let (tt2, t2) := sys.struct.get(t2, "type")

                     // TOKEN_COMMA := 13
                     if tt2 == 13 {
                         p_comma := parser_advance(p_pk2)
                         ref_parser := [p_comma]
                     } else {
                         ref_parser := [p_next]
                     }
                 }
             }

             let (final_parser, _) := sys.list.get(ref_parser, 0)

             node := {
                kind: NODE_EXPR_CALL,
                function: val,
                args: args
             }
             return [node, final_parser]
        }

        node := { kind: NODE_EXPR_VAR, name: val }
        return [node, p_after_id]
    }

    // Fallback error
    // Consume 1 to avoid infinite loop if stuck
    p_adv := parser_advance(p_peek)

    let (line, tok) := sys.struct.get(tok, "line")
    let (col, tok) := sys.struct.get(tok, "col")

    return [{kind: 99, value: "unexpected_primary", line: line, col: col}, p_adv]
}

func parse_func_args(parser) {
    // Expect (
    let (tok, p_peek) := parser_peek(parser)
    let (ttype, tok) := sys.struct.get(tok, "type")

    // TOKEN_LPAREN := 9
    // If we call this, we might have consumed func NAME already?
    // Let's assume passed parser is AT '('.

    p_curr := parser
    if ttype == 9 {
        p_curr := parser_advance(p_peek)
    } else {
        // Error or logic issue
        return [[], parser]
    }

    args := []
    ref_parser := [p_curr]
    running := true

    while running {
        let (p, _) := sys.list.get(ref_parser, 0)
        let (t, p_pk) := parser_peek(p)
        let (tt, t) := sys.struct.get(t, "type")

        // TOKEN_RPAREN := 10
        if tt == 10 {
            running := false
            p_final := parser_advance(p_pk)
            ref_parser := [p_final]
        } else if tt == 1 { // IDENTIFIER (Arg Name)
             let (name, t) := sys.struct.get(t, "value")
             args := sys.list.append(args, name)
             p_next := parser_advance(p_pk)

             // Check Comma
             let (t2, p_pk2) := parser_peek(p_next)
             let (tt2, t2) := sys.struct.get(t2, "type")

             if tt2 == 13 { // COMPO
                 p_comma := parser_advance(p_pk2)
                 ref_parser := [p_comma]
             } else {
                 ref_parser := [p_next]
             }
        } else {
            // Unexpected token in args
            running := false
            ref_parser := [p_pk]
        }
    }

    let (final_parser, _) := sys.list.get(ref_parser, 0)
    return [args, final_parser]
}

func parse_func_def(parser) {
    // Consumes 'func'
    let (tok, p_func) := parser_peek(parser)
    p_after_func := parser_advance(p_func)

    // Identifier
    let (tok2, p_peek2) := parser_peek(p_after_func)
    let (name, tok2) := sys.struct.get(tok2, "value")
    p_after_name := parser_advance(p_peek2)

    // Args
    let (args, p_after_args) := parse_func_args(p_after_name)

    // Body (Block)
    // parse_block expects {
    let (body_stmts, p_after_body) := parse_block(p_after_args)

    node := {
        kind: NODE_FUNC_DEF,
        name: name,
        args: args,
        body: body_stmts
    }

    return [node, p_after_body]
}

func parse_factor(parser) {
    // Left side: parse_primary
    let (lhs, p_curr) := parse_primary(parser)

    // Check for * or /
    // parser must be threaded.
    // We need a loop.

    ref_parser := [p_curr]
    ref_lhs := [lhs]

    running := true
    while running {
        let (p, _) := sys.list.get(ref_parser, 0)
        let (tok, p_peek) := parser_peek(p)
        let (ttype, tok) := sys.struct.get(tok, "type")

        // TOKEN_STAR := 7, TOKEN_SLASH := 8
        is_op := false
        if ttype == 7 { is_op := true }
        if ttype == 8 { is_op := true }

        if is_op {
            // Consume Op
            p_after_op := parser_advance(p_peek)

            // Parse RHS (Primary)
            let (rhs, p_after_rhs) := parse_primary(p_after_op)

            // Compose Binary Node
            let (prev_lhs, _) := sys.list.get(ref_lhs, 0)

            // Op Name
            op_name := "mul"
            if ttype == 8 { op_name := "div" }

            node := {
                kind: NODE_EXPR_BINARY,
                left: prev_lhs,
                right: rhs,
                op: op_name
            }

            // Update Refs
            ref_lhs := [node]
            ref_parser := [p_after_rhs]
        } else {
            running := false
            ref_parser := [p_peek] // Keep p_peek (didn't consume op)
            // Wait, parse_primary returned p_curr.
            // Loop started with p (which is p_curr).
            // We peeked p. If not op, we return p.
            // Correct.
        }
    }

    let (final_lhs, _) := sys.list.get(ref_lhs, 0)
    let (final_parser, _) := sys.list.get(ref_parser, 0)

    return [final_lhs, final_parser]
}

func parse_term(parser) {
    // Left side: parse_factor
    let (lhs, p_curr) := parse_factor(parser)

    // Check for + or -
    ref_parser := [p_curr]
    ref_lhs := [lhs]

    running := true
    while running {
        let (p, _) := sys.list.get(ref_parser, 0)
        let (tok, p_peek) := parser_peek(p)
        let (ttype, tok) := sys.struct.get(tok, "type")

        // TOKEN_PLUS := 5, TOKEN_MINUS := 6
        is_op := false
        if ttype == 5 { is_op := true }
        if ttype == 6 { is_op := true }

        if is_op {
            // Consume Op
            p_after_op := parser_advance(p_peek)

            // Parse RHS (Factor)
            let (rhs, p_after_rhs) := parse_factor(p_after_op)

            // Compose Binary Node
            let (prev_lhs, _) := sys.list.get(ref_lhs, 0)

            // Op Name
            op_name := "add"
            if ttype == 6 { op_name := "sub" }

            node := {
                kind: NODE_EXPR_BINARY,
                left: prev_lhs,
                right: rhs,
                op: op_name
            }

            // Update Refs
            ref_lhs := [node]
            ref_parser := [p_after_rhs]
        } else {
            running := false
            ref_parser := [p_peek]
        }
    }

    let (final_lhs, _) := sys.list.get(ref_lhs, 0)
    let (final_parser, _) := sys.list.get(ref_parser, 0)

    return [final_lhs, final_parser]
}

func parse_expr(parser) {
    return parse_term(parser)
}

func parse_block(parser) {
    // Consume {
    let (tok, p_brace) := parser_peek(parser)
    p_curr := parser_advance(p_brace)

    // Loop until } or EOF
    children := []
    ref_parser := [p_curr]

    running := true
    while running {
        let (p, _) := sys.list.get(ref_parser, 0)
        let (tok, p_peek) := parser_peek(p)
        let (ttype, tok) := sys.struct.get(tok, "type")

        // TOKEN_RBRACE := 12, TOKEN_EOF := 0
        if ttype == 12 {
            running := false
            p_after_block := parser_advance(p_peek)
            ref_parser := [p_after_block]
        } else if ttype == 0 {
            running := false
            ref_parser := [p_peek] // Stop at EOF
        } else {
            let (stmt, p_next) := parse_stmt(p_peek)
            children := sys.list.append(children, stmt)
            ref_parser := [p_next]
        }
    }

    let (final_parser, _) := sys.list.get(ref_parser, 0)

    return [children, final_parser]
}

func parse_if(parser) {
    // Consumes 'if' (Caller did peek, passed parser pointing to 'if')
    // Wait, caller of parse_stmt peeks. If we call parse_if, we should expect parser to be AT 'if'.
    // parse_stmt logic: peek -> is 'if' -> call parse_if.
    // parse_stmt should pass the parser *at* 'if', so parse_if consumes it.

    let (tok, p_if) := parser_peek(parser)
    p_after_if := parser_advance(p_if)

    // Condition
    let (cond, p_after_cond) := parse_expr(p_after_if)

    // Block (Then)
    // parse_block expects starting at '{'
    let (then_stmts, p_after_then) := parse_block(p_after_cond)

    // Check Else
    let (tok2, p_peek2) := parser_peek(p_after_then)
    let (ttype2, tok2) := sys.struct.get(tok2, "type")

    // TOKEN_KEYWORD_ELSE := 101
    else_block := [] // Empty list if no else
    // But we need Option logic or just empty list for block?
    // Runtime 'If' node expects `else_block: Option<List<Stmt>>`?
    // In `runtime.rs`, `Statement::If` has `else_block: Option<Vec<Statement>>`.
    // Ark lists are dynamic. We can pass [] or undefined?
    // Let's pass the list directly. Runtime might check length?
    // Wait, Runtime `eval.rs`: `else_block` is `Option`.
    // We can't easily construct Rust `Option` from here.
    // Ark Compiler `compile.py` converts Ark List to Rust Vec.
    // How to represent Option?
    // If I pass `else_block: []`, compiler might convert to `Some([])` or fail?
    // `compile.py` likely expects `else_block` to be a list if present.
    // If missing, `compile.py` sets it to `None`?
    // Looking at `compile.py` (checked earlier): `_compile_if` handles it.
    // Let's assume we pass `else_block` field if it exists.

    p_final := p_after_then
    has_else := false

    if ttype2 == 101 {
        // Consumes 'else'
        p_after_else := parser_advance(p_peek2)

        let (tok3, p_peek3) := parser_peek(p_after_else)
        let (ttype3, tok3) := sys.struct.get(tok3, "type")

        // If 'else if' -> Recursion?
        // TOKEN_KEYWORD_IF := 100
        if ttype3 == 100 {
            // Recurse: parse_if
            let (nested_if, p_after_nested) := parse_if(p_after_else)
            // Wrap in block? `else if` is just one stmt.
            else_block := [nested_if]
            p_final := p_after_nested
            has_else := true
        } else {
            // Block
            let (stmts, p_after_else_block) := parse_block(p_after_else)
            else_block := stmts
            p_final := p_after_else_block
            has_else := true
        }
    }

    node := {
        kind: NODE_IF,
        condition: cond,
        then_block: then_stmts
    }

    if has_else {
        node := sys.struct.set(node, "else_block", else_block)
    }

    return [node, p_final]
}

func parse_while(parser) {
    // Consumes 'while'
    let (tok, p_while) := parser_peek(parser)
    p_after_while := parser_advance(p_while)

    let (cond, p_after_cond) := parse_expr(p_after_while)
    let (stmts, p_final) := parse_block(p_after_cond)

    node := {
        kind: NODE_WHILE,
        condition: cond,
        body: stmts
    }

    return [node, p_final]
}

func parse_return(parser) {
    // Consumes 'return'
    let (tok, p_ret) := parser_peek(parser)
    p_after_ret := parser_advance(p_ret)

    let (val, p_final) := parse_expr(p_after_ret)

    node := {
        kind: NODE_RETURN,
        value: val
    }

    return [node, p_final]
}

func parse_stmt(parser) {
    // Look ahead to decide
    let (tok, p_stmt_peek) := parser_peek(parser)
    let (ttype, tok) := sys.struct.get(tok, "type")

    // Dispatch based on Token Type

    // TOKEN_KEYWORD_IF := 100
    if ttype == 100 {
        return parse_if(p_stmt_peek)
    }

    // TOKEN_KEYWORD_WHILE := 102
    if ttype == 102 {
        return parse_while(p_stmt_peek)
    }

    // TOKEN_KEYWORD_RETURN := 104
    if ttype == 104 {
        return parse_return(p_stmt_peek)
    }

    // Assignments (Identifier)
    if ttype == TOKEN_IDENTIFIER {
        // ... (Existing Assignment Logic) ...
        // Check for function call? `my_func()` is Stmt?
        // Assignments logic handles `x := ...`
        // What if `x = ...` (Reassignment)? Not supported yet?
        // Assignment Logic below:

        // Assume Assignment: IDENT := EXPR
        // Advance past Identifier (Consumes p_stmt_peek)
        p_after_id := parser_advance(p_stmt_peek)

        // Expect :=
        let (tok2, p_stmt_peek2) := parser_peek(p_after_id)
        let (ttype2, tok2) := sys.struct.get(tok2, "type")

        // TOKEN_ASSIGN := 16
        if ttype2 == TOKEN_ASSIGN {
             // Advance past :=
             p_after_assign := parser_advance(p_stmt_peek2)

             // Parse Expr (Expression!)
             // Previously: let (tok3, p_stmt_peek3) := parser_peek(p_after_assign) ...

             let (expr_node, p_after_expr) := parse_expr(p_after_assign)

             // Get ID Name from first token
             let (id_name, tok) := sys.struct.get(tok, "value")

             node := {
                kind: NODE_ASSIGN,
                name: id_name,
                value: expr_node
             }

             return [node, p_after_expr]
        } else {
             // Fallback if Identifier but NO :=
             p_adv := parser_advance(p_stmt_peek2)
             return [{kind: 99, value: "expected_assign"}, p_adv]
        }
    }

    // Fallback: Skip one token
    p_adv := parser_advance(p_stmt_peek)

    let (line, tok) := sys.struct.get(tok, "line")
    let (col, tok) := sys.struct.get(tok, "col")

    return [{kind: 99, value: "skipped", line: line, col: col}, p_adv]
}

func parse_program(tokens) {
    let (count, tokens) := sys.len(tokens)
    print("Parser Input Tokens: " + int_to_str(count))

    parser := parser_new(tokens)
    ref_parser := [parser]
    children := []

    running := true
    while running {
        let (p, _) := sys.list.get(ref_parser, 0)

        let (tok, p_prog_peek) := parser_peek(p)

        let (ttype, tok) := sys.struct.get(tok, "type")
        if ttype == TOKEN_EOF {
            running := false
            ref_parser := [p_prog_peek]
        } else if ttype == 103 { // TOKEN_KEYWORD_FUNC
            let (node, p_next) := parse_func_def(p_prog_peek)
            children := sys.list.append(children, node)
            ref_parser := [p_next]
        } else {
            // Use parse_stmt
            let (node, p_next) := parse_stmt(p_prog_peek)
            children := sys.list.append(children, node)
            ref_parser := [p_next]
        }
    }

    let (child_count, _) := sys.len(children)
    print("Parser Output Nodes: " + int_to_str(child_count))

    return {
        kind: NODE_PROGRAM,
        children: children
    }
}

// --- LSP Main ---

func int_to_str(i) {
    return "" + i
}

func print(msg) {
    sys.log(msg)
}

func read_header() {
    content_len := 0
    running := true
    while running {
        line := sys.io.read_line()
        if line == "" { return -1 }
        if (line == "\r\n") || (line == "\n") {
            running := false
        } else {
             match := true
             prefix := "Content-Length:"
             
             let (len_line, _) := sys.len(line)
             if len_line < 15 {
                 match := false
             } else {
                 i := 0
                 while i < 15 {
                     let (c, _) := sys.str.get(line, i)
                     let (p, _) := sys.str.get(prefix, i)
                     if c != p { match := false }
                     i := i + 1
                 }
             }

             if match {
                 j := 15
                 let (c, _) := sys.str.get(line, j)
                 if c == " " { j := j + 1 }

                 num_str := ""
                 collecting := true
                 while collecting {
                     let (c, _) := sys.str.get(line, j)
                     if (c >= "0") && (c <= "9") {
                         num_str := num_str + c
                         j := j + 1
                     } else {
                         collecting := false
                     }
                 }
                 if num_str != "" {
                     content_len := sys.json.parse(num_str)
                 }
             }
        }
    }
    return content_len
}

func handle_message(msg) {
    has_method := sys.struct.has(msg, "method")
    if has_method == false { return 0 }

    let (method, _) := sys.struct.get(msg, "method")
    sys.log("Method: " + method)

    if method == "initialize" {
        has_id := sys.struct.has(msg, "id")
        if has_id {
            let (id, _) := sys.struct.get(msg, "id")
            res := {
                capabilities: {
                    textDocumentSync: 1
                }
            }
            send_response(id, res)
        }
    } else if method == "shutdown" {
        has_id := sys.struct.has(msg, "id")
        if has_id {
            let (id, _) := sys.struct.get(msg, "id")
            // Send null (Unit) as result
            // Ark Unit is passed as None to python json parser?
            // Yes, from_ark returns None for Unit.
            // But we can't create literal Unit easily in Ark source except from void function.
            // Or pass a variable that is Unit.
            // Let's pass a string "null" and rely on client? No, must be null.
            // I'll create a helper `get_null()`?
            // Or just `{}` and client ignores?
            // `sys.json.parse("null")` returns Unit.
            null_val := sys.json.parse("null")
            send_response(id, null_val)
        }
    } else if method == "exit" {
        sys.exit(0)
    } else if method == "textDocument/didOpen" {
        let (params, _) := sys.struct.get(msg, "params")
        let (doc, _) := sys.struct.get(params, "textDocument")
        let (uri, _) := sys.struct.get(doc, "uri")
        let (text, _) := sys.struct.get(doc, "text")
        validate(uri, text)
    } else if method == "textDocument/didChange" {
        let (params, _) := sys.struct.get(msg, "params")
        let (doc, _) := sys.struct.get(params, "textDocument")
        let (uri, _) := sys.struct.get(doc, "uri")
        let (changes, _) := sys.struct.get(params, "contentChanges")
        let (first, _) := sys.list.get(changes, 0)
        let (text, _) := sys.struct.get(first, "text")
        validate(uri, text)
    }
}

func validate(uri, text) {
    sys.log("Validating: " + uri)

    tokens := lexer_tokenize(text)
    ast := parse_program(tokens)

    errors := []
    collect_errors(ast, errors)

    send_notification("textDocument/publishDiagnostics", {
        uri: uri,
        diagnostics: errors
    })
}

func collect_errors(node, errors) {
    has_kind := sys.struct.has(node, "kind")
    if has_kind == false { return 0 }

    let (kind, _) := sys.struct.get(node, "kind")

    if kind == 99 {
        let (msg, _) := sys.struct.get(node, "value")
        let (line, _) := sys.struct.get(node, "line")
        let (col, _) := sys.struct.get(node, "col")

        l := line - 1
        c := col - 1

        diag := {
            range: {
                start: { line: l, character: c },
                end: { line: l, character: c + 1 }
            },
            severity: 1,
            message: "Syntax Error: " + msg,
            source: "ark-lsp"
        }
        sys.list.append(errors, diag)
        return 0
    }

    traverse_list(node, "children", errors)
    traverse_list(node, "body", errors)
    traverse_list(node, "then_block", errors)
    traverse_list(node, "else_block", errors)

    traverse_node(node, "expression", errors)
    traverse_node(node, "condition", errors)
    traverse_node(node, "left", errors)
    traverse_node(node, "right", errors)
    traverse_node(node, "value", errors)
}

func traverse_list(parent, field, errors) {
    if sys.struct.has(parent, field) {
        let (lst, _) := sys.struct.get(parent, field)
        // Check if list via sys.len
        // If it fails, catch? No catch.
        // We assume schema correctness.
        // Or check type via intrinsic? No typeof.
        // But field "children" is always list in parser.

        // Safety: If field exists, assume it is list for these fields.
        let (len, _) := sys.len(lst)
        i := 0
        while i < len {
            let (child, _) := sys.list.get(lst, i)
            collect_errors(child, errors)
            i := i + 1
        }
    }
}

func traverse_node(parent, field, errors) {
    if sys.struct.has(parent, field) {
        let (child, _) := sys.struct.get(parent, field)
        collect_errors(child, errors)
    }
}

func send_response(id, result) {
    obj := {
        jsonrpc: "2.0",
        id: id,
        result: result
    }
    send_json(obj)
}

func send_notification(method, params) {
    obj := {
        jsonrpc: "2.0",
        method: method,
        params: params
    }
    send_json(obj)
}

func send_json(obj) {
    body := sys.json.stringify(obj)
    let (l, _) := sys.len(body)
    header := "Content-Length: " + int_to_str(l) + "\r\n\r\n"
    sys.io.write(header + body)
}

func main() {
    sys.log("Ark LSP Started")
    while true {
        len := read_header()
        if len == -1 { sys.exit(0) }
        if len > 0 {
            body := sys.io.read_bytes(len)
            msg := sys.json.parse(body)
            handle_message(msg)
        }
    }
}

main()
