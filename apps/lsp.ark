
// --- LSP Library ---

// --- Constants ---
TOKEN_EOF := 0
TOKEN_IDENTIFIER := 1
TOKEN_NUMBER := 2
TOKEN_STRING := 3
TOKEN_SYMBOL := 4
TOKEN_KEYWORD := 5

// Keywords (Must match Parser)
TOKEN_KEYWORD_IF := 100
TOKEN_KEYWORD_ELSE := 101
TOKEN_KEYWORD_WHILE := 102
TOKEN_KEYWORD_FUNC := 103
TOKEN_KEYWORD_RETURN := 104
TOKEN_KEYWORD_LET := 105
TOKEN_KEYWORD_TRUE := 106
TOKEN_KEYWORD_FALSE := 107
TOKEN_KEYWORD_IMPORT := 108
TOKEN_KEYWORD_STRUCT := 109
TOKEN_KEYWORD_MATCH := 110

// --- AST Node Types ---
NODE_PROGRAM := 0
NODE_FUNC_DEF := 1
NODE_BLOCK := 2
NODE_IF := 3
NODE_WHILE := 4
NODE_RETURN := 5
NODE_LET := 6
NODE_ASSIGN := 7
NODE_EXPR_BINARY := 8
NODE_EXPR_CALL := 9
NODE_EXPR_LITERAL_INT := 10
NODE_EXPR_LITERAL_STR := 11
NODE_EXPR_VAR := 12
NODE_EXPR_LITERAL_BOOL := 13

// --- Helpers ---

func int_to_str(i) {
    return "" + i
}

func is_digit(char_str) {
    return (char_str >= "0") and (char_str <= "9")
}

func is_alpha(char_str) {
    return ((char_str >= "a") and (char_str <= "z")) or ((char_str >= "A") and (char_str <= "Z")) or (char_str == "_") or (char_str == ".")
}

func is_whitespace(char_str) {
    return (char_str == " ") or (char_str == "\n") or (char_str == "\t") or (char_str == "\r")
}

// --- Lexer ---

func lexer_new(source) {
    let (l, src) := sys.len(source)
    return {
        source: src,
        length: l,
        pos: 0,
        line: 0,
        col: 0,
        tokens: []
    }
}

func lexer_peek(lexer) {
    if lexer.pos >= lexer.length {
        return "" // EOF
    }
    let (c, src) := sys.str.get(lexer.source, lexer.pos)
    return c
}

func lexer_advance(lexer) {
    c := lexer_peek(lexer)
    lexer.pos := lexer.pos + 1
    if c == "\n" {
        lexer.line := lexer.line + 1
        lexer.col := 0
    } else {
        lexer.col := lexer.col + 1
    }
    return lexer
}

func lexer_add_token(lexer, type, value) {
    // Calculate end position based on value length
    let (val_len, _) := sys.len(value)

    // Start is current lexer.line/col - val_len (roughly, if on same line)
    // But lexer_advance updates line/col.
    // Better strategy: capture start pos before scanning token.
    // But here we are adding after scanning.
    // We can use lexer.line/col as END.
    // START = END - len.
    // This assumes single line tokens. Multiline strings break this.
    // For now, assume single line tokens.

    end_line := lexer.line
    end_col := lexer.col
    start_line := end_line
    start_col := end_col - val_len

    if start_col < 0 { start_col := 0 } // Safety

    token := {
        type: type,
        value: value,
        range: {
            start: { line: start_line, character: start_col },
            end: { line: end_line, character: end_col }
        }
    }
    lexer.tokens := sys.list.append(lexer.tokens, token)
    return lexer
}

func check_keyword(ident_str) {
    if ident_str == "if" { return 100 }
    if ident_str == "else" { return 101 }
    if ident_str == "while" { return 102 }
    if ident_str == "func" { return 103 }
    if ident_str == "return" { return 104 }
    if ident_str == "let" { return 105 }
    if ident_str == "true" { return 106 }
    if ident_str == "false" { return 107 }
    if ident_str == "import" { return 108 }
    if ident_str == "struct" { return 109 }
    if ident_str == "match" { return 110 }
    return 1 // TOKEN_IDENTIFIER
}

func lexer_scan(lexer) {
    char_str := lexer_peek(lexer)

    if char_str == "" {
        lexer := lexer_add_token(lexer, TOKEN_EOF, "")
        return lexer
    }

    if is_whitespace(char_str) {
        lexer := lexer_advance(lexer)
        return lexer_scan(lexer)
    }

    if is_digit(char_str) {
        num_str := ""
        while is_digit(lexer_peek(lexer)) {
            num_str := num_str + lexer_peek(lexer)
            lexer := lexer_advance(lexer)
        }
        lexer := lexer_add_token(lexer, TOKEN_NUMBER, num_str)
        return lexer
    }

    if is_alpha(char_str) {
        ident_str := ""
        while is_alpha(lexer_peek(lexer)) or is_digit(lexer_peek(lexer)) {
            ident_str := ident_str + lexer_peek(lexer)
            lexer := lexer_advance(lexer)
        }

        token_type := check_keyword(ident_str)
        lexer := lexer_add_token(lexer, token_type, ident_str)
        return lexer
    }

    if char_str == "\"" {
        lexer := lexer_advance(lexer) // Skip start quote
        str_val := ""
        while (lexer_peek(lexer) != "\"") and (lexer_peek(lexer) != "") {
            str_val := str_val + lexer_peek(lexer)
            lexer := lexer_advance(lexer)
        }
        if lexer_peek(lexer) == "\"" {
            lexer := lexer_advance(lexer) // Skip end quote
        }
        // Token value includes quotes? Usually string literal value doesn't.
        // But for range calculation, we need full length including quotes.
        // Let's store raw value including quotes for range, but value field for AST?
        // Let's store value as the content string.
        // Adjust range manually.

        let (content_len, _) := sys.len(str_val)
        full_len := content_len + 2

        end_line := lexer.line
        end_col := lexer.col
        start_line := end_line
        start_col := end_col - full_len

        token := {
            type: TOKEN_STRING,
            value: str_val,
            range: {
                start: { line: start_line, character: start_col },
                end: { line: end_line, character: end_col }
            }
        }
        lexer.tokens := sys.list.append(lexer.tokens, token)
        return lexer
    }

    // Comments
    if char_str == "/" {
        if (lexer.pos + 1) < lexer.length {
            let (next_char, _src) := sys.str.get(lexer.source, lexer.pos + 1)
            if next_char == "/" {
                 looping := true
                 while looping {
                     lexer := lexer_advance(lexer)
                     c := lexer_peek(lexer)
                     if c == "\n" { looping := false }
                     if c == "" { looping := false }
                 }
                 return lexer_scan(lexer)
            }
        }
    }

    // Symbols
    // Handle :=
    if char_str == ":" {
        if (lexer.pos + 1) < lexer.length {
            let (next_char, _src) := sys.str.get(lexer.source, lexer.pos + 1)
            if next_char == "=" {
                 lexer := lexer_advance(lexer) // :
                 lexer := lexer_advance(lexer) // =
                 lexer := lexer_add_token(lexer, 16, ":=") // TOKEN_ASSIGN
                 return lexer
            }
        }
    }

    // Handle ==
    if char_str == "=" {
        if (lexer.pos + 1) < lexer.length {
            let (next_char, _src) := sys.str.get(lexer.source, lexer.pos + 1)
            if next_char == "=" {
                 lexer := lexer_advance(lexer)
                 lexer := lexer_advance(lexer)
                 lexer := lexer_add_token(lexer, 21, "==")
                 return lexer
            }
        }
    }

    lexer := lexer_advance(lexer)
    lexer := lexer_add_token(lexer, TOKEN_SYMBOL, char_str)
    return lexer
}

func lexer_tokenize(source) {
    lexer := lexer_new(source)
    running := true
    while running {
        let (count, tokens_ref) := sys.len(lexer.tokens)
        lexer.tokens := tokens_ref
        if count > 0 {
            last_token := sys.list.get(lexer.tokens, count - 1)
            let (token_val, token_list) := last_token
            type := token_val.type
            if type == TOKEN_EOF {
                running := false
            } else {
                lexer := lexer_scan(lexer)
            }
        } else {
            lexer := lexer_scan(lexer)
        }
    }
    return lexer.tokens
}

// --- Parser ---

func parser_new(tok_input) {
    return {
        tokens: tok_input,
        pos: 0
    }
}

func parser_peek(parser) {
    let (tok_list, parser) := sys.struct.get(parser, "tokens")
    let (pos, parser) := sys.struct.get(parser, "pos")

    let (len, _) := sys.len(tok_list)
    if pos >= len {
        // Safe EOF
        if len > 0 {
            let (last_tok, _) := sys.list.get(tok_list, len - 1)
            return [last_tok, parser]
        } else {
            return [{type: 0, value: "", range: {start: {line: 0, character: 0}, end: {line: 0, character: 0}}}, parser]
        }
    }

    let (tok, tok_list) := sys.list.get(tok_list, pos)
    parser := sys.struct.set(parser, "tokens", tok_list)
    return [tok, parser]
}

func parser_advance(parser) {
    let (pos, parser) := sys.struct.get(parser, "pos")
    new_pos := pos + 1
    parser := sys.struct.set(parser, "pos", new_pos)
    return parser
}

func make_node(kind, start_tok, end_tok, props) {
    // start_tok and end_tok are tokens with `range`
    let (start_range, _) := sys.struct.get(start_tok, "range")
    let (end_range, _) := sys.struct.get(end_tok, "range")

    let (start_pos, _) := sys.struct.get(start_range, "start")
    let (end_pos, _) := sys.struct.get(end_range, "end")

    range := {
        start: start_pos,
        end: end_pos
    }

    node := {
        kind: kind,
        range: range
    }

    // Merge props
    // Assume props is an Instance (Struct)
    // We can iterate keys? No.
    // We have to set fields manually or copy manually.
    // Ark doesn't support merging structs easily without iterating keys (which we can't do natively yet unless sys.struct.keys exists).
    // So caller should pass the fully constructed node, and we just add range.

    // Let's change signature: make_node(node, start_tok, end_tok)

    // But props was just fields.
    // Let's implement sys.struct.merge? No.

    // Workaround: We pass the object, we set range on it.

    return sys.struct.set(props, "range", range)
}

func parse_primary(parser) {
    let (tok, p_peek) := parser_peek(parser)
    let (ttype, tok) := sys.struct.get(tok, "type")

    if ttype == TOKEN_NUMBER {
        let (val, tok) := sys.struct.get(tok, "value")
        p_adv := parser_advance(p_peek)
        node := { kind: NODE_EXPR_LITERAL_INT, value: val }
        node := sys.struct.set(node, "range", tok.range)
        return [node, p_adv]
    }

    if ttype == TOKEN_STRING {
        let (val, tok) := sys.struct.get(tok, "value")
        p_adv := parser_advance(p_peek)
        node := { kind: NODE_EXPR_LITERAL_STR, value: val }
        node := sys.struct.set(node, "range", tok.range)
        return [node, p_adv]
    }

    if ttype == TOKEN_KEYWORD_TRUE {
        p_adv := parser_advance(p_peek)
        node := { kind: NODE_EXPR_LITERAL_BOOL, value: 1 }
        node := sys.struct.set(node, "range", tok.range)
        return [node, p_adv]
    }

    if ttype == TOKEN_KEYWORD_FALSE {
        p_adv := parser_advance(p_peek)
        node := { kind: NODE_EXPR_LITERAL_BOOL, value: 0 }
        node := sys.struct.set(node, "range", tok.range)
        return [node, p_adv]
    }

    if ttype == TOKEN_IDENTIFIER {
        let (val, tok) := sys.struct.get(tok, "value")
        p_after_id := parser_advance(p_peek)

        let (tok2, p_peek2) := parser_peek(p_after_id)
        let (val2, tok2) := sys.struct.get(tok2, "value")

        if val2 == "(" {
             p_after_paren := parser_advance(p_peek2)

             args := []
             ref_parser := [p_after_paren]
             running := true

             // Track end token for range (RPAREN)
             end_tok := tok2 // Default to LPAREN if empty args (wrong but safe)

             while running {
                 let (p, _) := sys.list.get(ref_parser, 0)
                 let (t, p_pk) := parser_peek(p)
                 let (val_t, t) := sys.struct.get(t, "value")
                 let (tt, t) := sys.struct.get(t, "type")

                 if tt == TOKEN_EOF {
                     running := false
                 } else if val_t == ")" {
                     end_tok := t
                     running := false
                     p_after_args := parser_advance(p_pk)
                     ref_parser := [p_after_args]
                 } else {
                     let (arg_expr, p_next) := parse_expr(p_pk)
                     args := sys.list.append(args, arg_expr)

                     let (t2, p_pk2) := parser_peek(p_next)
                     let (val_t2, t2) := sys.struct.get(t2, "value")

                     if val_t2 == "," {
                         p_comma := parser_advance(p_pk2)
                         ref_parser := [p_comma]
                     } else {
                         ref_parser := [p_next]
                     }
                 }
             }

             let (final_parser, _) := sys.list.get(ref_parser, 0)

             node := {
                kind: NODE_EXPR_CALL,
                function: val,
                args: args
             }

             // Range: Identifier Start to RPAREN End
             range := {
                 start: tok.range.start,
                 end: end_tok.range.end
             }
             node := sys.struct.set(node, "range", range)

             return [node, final_parser]
        }

        node := { kind: NODE_EXPR_VAR, name: val }
        node := sys.struct.set(node, "range", tok.range)
        return [node, p_after_id]
    }

    p_adv := parser_advance(p_peek)
    return [{kind: 99, value: "unexpected_primary", line: tok.range.start.line, col: tok.range.start.character}, p_adv]
}

func parse_expr(parser) {
    return parse_primary(parser) // Simplified for brevity (no binary ops yet for LSP demo)
}

func parse_block(parser) {
    let (tok_start, p_brace) := parser_peek(parser)
    p_curr := parser_advance(p_brace)

    children := []
    ref_parser := [p_curr]
    end_tok := tok_start

    running := true
    while running {
        let (p, _) := sys.list.get(ref_parser, 0)
        let (tok, p_peek) := parser_peek(p)
        let (val_tok, tok) := sys.struct.get(tok, "value")

        if val_tok == "}" {
            end_tok := tok
            running := false
            p_after_block := parser_advance(p_peek)
            ref_parser := [p_after_block]
        } else if val_tok == "" { // EOF
            end_tok := tok
            running := false
            ref_parser := [p_peek]
        } else {
            let (stmt, p_next) := parse_stmt(p_peek)
            children := sys.list.append(children, stmt)
            ref_parser := [p_next]
        }
    }

    let (final_parser, _) := sys.list.get(ref_parser, 0)

    range := {
        start: tok_start.range.start,
        end: end_tok.range.end
    }

    // Block is list of statements, but let's wrap it in NODE_BLOCK?
    // Or just return children list?
    // Caller expects list? parse_func_def expects list.
    // But parse_block should return range info.
    // So let's return a Block Node.

    node := {
        kind: NODE_BLOCK,
        children: children,
        range: range
    }

    return [node, final_parser]
}

func parse_func_def(parser) {
    let (tok_start, p_func) := parser_peek(parser)
    p_after_func := parser_advance(p_func)

    let (tok2, p_peek2) := parser_peek(p_after_func)
    let (name, tok2) := sys.struct.get(tok2, "value")
    p_after_name := parser_advance(p_peek2)

    // Skip args parsing for brevity (LSP demo), assume ()
    ref_parser := [p_after_name]
    running := true
    while running {
         let (p, _) := sys.list.get(ref_parser, 0)
         let (t, p_pk) := parser_peek(p)
         let (v, t) := sys.struct.get(t, "value")
         let (tt, t) := sys.struct.get(t, "type")

         if tt == TOKEN_EOF {
             running := false
         } else if v == "{" {
             running := false
         } else {
             p_next := parser_advance(p_pk)
             ref_parser := [p_next]
         }
    }
    let (p_before_block, _) := sys.list.get(ref_parser, 0)

    let (body_node, p_after_body) := parse_block(p_before_block)

    node := {
        kind: NODE_FUNC_DEF,
        name: name,
        args: [], // Skipped
        body: body_node.children
    }

    range := {
        start: tok_start.range.start,
        end: body_node.range.end
    }
    node := sys.struct.set(node, "range", range)

    return [node, p_after_body]
}

func parse_return(parser) {
    let (tok_start, p_ret) := parser_peek(parser)
    p_after_ret := parser_advance(p_ret)

    let (val, p_final) := parse_expr(p_after_ret)

    let (end_range, _) := sys.struct.get(val, "range")
    let (end_pos, _) := sys.struct.get(end_range, "end")

    range := {
        start: tok_start.range.start,
        end: end_pos
    }

    node := {
        kind: NODE_RETURN,
        value: val,
        range: range
    }
    return [node, p_final]
}

func parse_if(parser) {
    let (tok_start, p_if) := parser_peek(parser)
    p_after_if := parser_advance(p_if)

    let (cond, p_after_cond) := parse_expr(p_after_if)
    let (body_node, p_after_body) := parse_block(p_after_cond)

    range := {
        start: tok_start.range.start,
        end: body_node.range.end
    }

    node := {
        kind: NODE_IF,
        condition: cond,
        then_block: body_node.children,
        range: range
    }
    // Handle else? Skipped for brevity
    return [node, p_after_body]
}

func parse_while(parser) {
    let (tok_start, p_while) := parser_peek(parser)
    p_after_while := parser_advance(p_while)

    let (cond, p_after_cond) := parse_expr(p_after_while)
    let (body_node, p_after_body) := parse_block(p_after_cond)

    range := {
        start: tok_start.range.start,
        end: body_node.range.end
    }

    node := {
        kind: NODE_WHILE,
        condition: cond,
        body: body_node.children,
        range: range
    }
    return [node, p_after_body]
}

func parse_stmt(parser) {
    let (tok, p_stmt_peek) := parser_peek(parser)
    let (ttype, tok) := sys.struct.get(tok, "type")

    if ttype == TOKEN_KEYWORD_FUNC { return parse_func_def(p_stmt_peek) }
    if ttype == TOKEN_KEYWORD_RETURN { return parse_return(p_stmt_peek) }
    if ttype == TOKEN_KEYWORD_IF { return parse_if(p_stmt_peek) }
    if ttype == TOKEN_KEYWORD_WHILE { return parse_while(p_stmt_peek) }

    // Assignments/Exprs
    let (expr, p_next) := parse_expr(p_stmt_peek)

    // Check for assignment :=
    let (tok2, p_peek2) := parser_peek(p_next)
    let (val2, tok2) := sys.struct.get(tok2, "value")

    if val2 == ":=" {
        p_assign := parser_advance(p_peek2)
        let (val_expr, p_final) := parse_expr(p_assign)

        let (name, _) := sys.struct.get(expr, "name") // Assume LHS is var

        let (start_r, _) := sys.struct.get(expr, "range")
        let (end_r, _) := sys.struct.get(val_expr, "range")

        range := {
            start: start_r.start,
            end: end_r.end
        }

        node := {
            kind: NODE_ASSIGN,
            name: name,
            value: val_expr,
            range: range
        }
        return [node, p_final]
    }

    return [expr, p_next]
}

func parse_program(tokens) {
    parser := parser_new(tokens)
    ref_parser := [parser]
    children := []

    running := true
    while running {
        let (p, _) := sys.list.get(ref_parser, 0)
        let (tok, p_prog_peek) := parser_peek(p)
        let (ttype, tok) := sys.struct.get(tok, "type")

        if ttype == TOKEN_EOF {
            running := false
            ref_parser := [p_prog_peek]
        } else {
            let (node, p_next) := parse_stmt(p_prog_peek)
            children := sys.list.append(children, node)
            ref_parser := [p_next]
        }
    }

    // Calculate range for PROGRAM
    // 0,0 to last token end
    // Assume 0,0 start

    end_range := { line: 0, character: 0 }
    // Get last token
    let (tlen, _) := sys.len(tokens)
    if tlen > 0 {
        let (last_tok, _) := sys.list.get(tokens, tlen - 1)
        let (r, _) := sys.struct.get(last_tok, "range")
        let (e, _) := sys.struct.get(r, "end")
        end_range := e
    }

    prog_range := {
        start: { line: 0, character: 0 },
        end: end_range
    }

    return {
        kind: NODE_PROGRAM,
        children: children,
        range: prog_range
    }
}

// --- LSP Logic ---

func in_range(line, col, range) {
    let (start, _) := sys.struct.get(range, "start")
    let (end, _) := sys.struct.get(range, "end")

    s_line := start.line
    s_col := start.character
    e_line := end.line
    e_col := end.character

    if (line < s_line) or (line > e_line) { return false }
    if (line == s_line) and (col < s_col) { return false }
    if (line == e_line) and (col > e_col) { return false }

    return true
}

func find_node_at_pos(node, line, col) {
    // Check if node has range
    has_range := sys.struct.has(node, "range")
    if has_range == false { return node } // Or null?

    let (range, _) := sys.struct.get(node, "range")
    if in_range(line, col, range) == false { return 0 } // 0 as null

    // Check children fields
    fields := ["children", "body", "then_block", "else_block", "args"]
    let (flen, _) := sys.len(fields)
    k := 0
    while k < flen {
        let (fname, _) := sys.list.get(fields, k)
        if sys.struct.has(node, fname) {
            let (children, _) := sys.struct.get(node, fname)
            // Check if list
            // We assume it is list.
            // Check length
            let (len, _) := sys.len(children)
            i := 0
            while i < len {
                let (child, _) := sys.list.get(children, i)
                // Check if child is struct (has range)
                if sys.struct.has(child, "range") {
                    res := find_node_at_pos(child, line, col)
                    if res != 0 { return res }
                }
                i := i + 1
            }
        }
        k := k + 1
    }

    // Check singular fields
    node_fields := ["condition", "expression", "value", "left", "right"]
    let (nlen, _) := sys.len(node_fields)
    j := 0
    while j < nlen {
        let (fname, _) := sys.list.get(node_fields, j)
        if sys.struct.has(node, fname) {
            let (child, _) := sys.struct.get(node, fname)
            if sys.struct.has(child, "range") {
                res := find_node_at_pos(child, line, col)
                if res != 0 { return res }
            }
        }
        j := j + 1
    }

    // Only return self if no child matched (most specific)
    return node
}

func handle_completion(params) {
    // Return hardcoded list
    items := []

    keywords := ["if", "else", "while", "func", "return", "let", "true", "false", "import", "struct", "match"]
    intrinsics := ["sys.print", "sys.exit", "math.sin", "crypto.sha256", "sys.io.read_line", "sys.log"]

    // Add keywords
    let (k_len, _) := sys.len(keywords)
    i := 0
    while i < k_len {
        let (k, _) := sys.list.get(keywords, i)
        item := { label: k, kind: 14 } // Keyword
        items := sys.list.append(items, item)
        i := i + 1
    }

    // Add intrinsics
    let (i_len, _) := sys.len(intrinsics)
    j := 0
    while j < i_len {
        let (k, _) := sys.list.get(intrinsics, j)
        item := { label: k, kind: 3 } // Function
        items := sys.list.append(items, item)
        j := j + 1
    }

    return { isIncomplete: false, items: items }
}

func handle_hover(params, ast) {
    let (pos, _) := sys.struct.get(params, "position")
    let (line, _) := sys.struct.get(pos, "line")
    let (col, _) := sys.struct.get(pos, "character")

    node := find_node_at_pos(ast, line, col)
    if node == 0 { return 0 }

    let (kind, _) := sys.struct.get(node, "kind")

    // If identifier
    if kind == NODE_EXPR_VAR { // Var access
        let (name, _) := sys.struct.get(node, "name")
        return {
            contents: {
                kind: "markdown",
                value: "**Variable**: " + name
            }
        }
    }

    if kind == NODE_FUNC_DEF {
        let (name, _) := sys.struct.get(node, "name")
        return {
            contents: {
                kind: "markdown",
                value: "**Function Definition**: " + name
            }
        }
    }

    if kind == NODE_EXPR_CALL {
        let (name, _) := sys.struct.get(node, "function")
        return {
            contents: {
                kind: "markdown",
                value: "**Function Call**: " + name
            }
        }
    }

    return 0
}

func collect_diagnostics(node, errors) {
    if sys.struct.has(node, "kind") == false { return 0 }
    let (kind, _) := sys.struct.get(node, "kind")

    if kind == 99 {
        let (msg, _) := sys.struct.get(node, "value")
        let (line, _) := sys.struct.get(node, "line")
        let (col, _) := sys.struct.get(node, "col")

        diag := {
            range: {
                start: { line: line, character: col },
                end: { line: line, character: col + 1 }
            },
            severity: 1,
            message: "Syntax Error: " + msg,
            source: "ark-lsp"
        }
        sys.list.append(errors, diag)
        return 0
    }

    // Lists
    lists := ["children", "body", "then_block", "else_block", "args"]
    let (llen, _) := sys.len(lists)
    k := 0
    while k < llen {
        let (fname, _) := sys.list.get(lists, k)
        if sys.struct.has(node, fname) {
            let (lst, _) := sys.struct.get(node, fname)
            let (len, _) := sys.len(lst)
            i := 0
            while i < len {
                let (child, _) := sys.list.get(lst, i)
                collect_diagnostics(child, errors)
                i := i + 1
            }
        }
        k := k + 1
    }

    // Nodes
    nodes := ["expression", "value", "condition", "left", "right"]
    let (nlen, _) := sys.len(nodes)
    j := 0
    while j < nlen {
        let (fname, _) := sys.list.get(nodes, j)
        if sys.struct.has(node, fname) {
            let (child, _) := sys.struct.get(node, fname)
            collect_diagnostics(child, errors)
        }
        j := j + 1
    }
    return 0
}

func handle_definition(params, ast) {
    let (pos, _) := sys.struct.get(params, "position")
    let (line, _) := sys.struct.get(pos, "line")
    let (col, _) := sys.struct.get(pos, "character")

    node := find_node_at_pos(ast, line, col)
    if node == 0 { return 0 }

    let (kind, _) := sys.struct.get(node, "kind")

    target_name := ""
    if kind == NODE_EXPR_CALL {
        let (name, _) := sys.struct.get(node, "function")
        target_name := name
    } else if kind == NODE_EXPR_VAR {
        let (name, _) := sys.struct.get(node, "name")
        target_name := name
    } else {
        return 0
    }

    // Scan AST for FUNC_DEF with name
    // Simplistic scan of top-level children
    let (children, _) := sys.struct.get(ast, "children")
    let (len, _) := sys.len(children)
    i := 0
    while i < len {
        let (child, _) := sys.list.get(children, i)
        let (ckind, _) := sys.struct.get(child, "kind")
        if ckind == NODE_FUNC_DEF {
            let (cname, _) := sys.struct.get(child, "name")
            if cname == target_name {
                 let (range, _) := sys.struct.get(child, "range")
                 return {
                     uri: params.textDocument.uri, // Same file
                     range: range
                 }
            }
        }
        i := i + 1
    }

    return 0
}

// --- Server Loop ---

func read_header() {
    content_len := 0
    running := true
    while running {
        line := sys.io.read_line()
        if line == "" { return -1 }

        // Check for empty line (\r\n or \n)
        is_empty := false
        if line == "\r\n" { is_empty := true }
        if line == "\n" { is_empty := true }

        if is_empty {
            running := false
        } else {
             // Check prefix "Content-Length:"
             // Length 15
             prefix := "Content-Length:"
             let (len_line, _) := sys.len(line)
             match := true
             if len_line < 15 { match := false }
             else {
                 k := 0
                 while k < 15 {
                     let (c1, _) := sys.str.get(line, k)
                     let (c2, _) := sys.str.get(prefix, k)
                     if c1 != c2 { match := false }
                     k := k + 1
                 }
             }

             if match {
                 // Extract number
                 j := 15
                 num_str := ""
                 while j < len_line {
                     let (c, _) := sys.str.get(line, j)
                     if is_digit(c) {
                         num_str := num_str + c
                     }
                     j := j + 1
                 }
                 if num_str != "" {
                     content_len := sys.json.parse(num_str)
                 }
             }
        }
    }
    return content_len
}

func send_json(obj) {
    body := sys.json.stringify(obj)
    let (l, _) := sys.len(body)
    header := "Content-Length: " + int_to_str(l) + "\r\n\r\n"
    sys.io.write(header + body)
}

func send_response(id, result) {
    obj := { jsonrpc: "2.0", id: id, result: result }
    send_json(obj)
}

func send_notification(method, params) {
    obj := { jsonrpc: "2.0", method: method, params: params }
    send_json(obj)
}

// Global state for document text/AST
// We can't use global var easily. Pass state around?
// Use a closure or object?
// main loop will hold state.

func run_server() {
    sys.log("Ark LSP Server Running...")

    current_doc_text := ""
    current_ast := {}

    while true {
        len := read_header()
        if len == -1 { sys.exit(0) }

        if len > 0 {
            body := sys.io.read_bytes(len)
            msg := sys.json.parse(body)

            let (method, _) := sys.struct.get(msg, "method")
            sys.log("Method: " + method)

            // Check ID
            has_id := sys.struct.has(msg, "id")
            id := 0
            if has_id {
                let (val_id, _) := sys.struct.get(msg, "id")
                id := val_id
            }

            if method == "initialize" {
                res := {
                    capabilities: {
                        textDocumentSync: 1,
                        completionProvider: { triggerCharacters: ["."] },
                        hoverProvider: true,
                        definitionProvider: true
                    },
                    serverInfo: { name: "ark-lsp", version: "0.1.0" }
                }
                send_response(id, res)
            } else if method == "textDocument/didOpen" {
                let (params, _) := sys.struct.get(msg, "params")
                let (doc, _) := sys.struct.get(params, "textDocument")
                let (text, _) := sys.struct.get(doc, "text")
                let (uri, _) := sys.struct.get(doc, "uri")

                current_doc_text := text
                tokens := lexer_tokenize(text)
                current_ast := parse_program(tokens)

                diagnostics := []
                collect_diagnostics(current_ast, diagnostics)
                send_notification("textDocument/publishDiagnostics", { uri: uri, diagnostics: diagnostics })

            } else if method == "textDocument/didChange" {
                let (params, _) := sys.struct.get(msg, "params")
                let (changes, _) := sys.struct.get(params, "contentChanges")
                let (first, _) := sys.list.get(changes, 0)
                let (text, _) := sys.struct.get(first, "text")
                let (doc, _) := sys.struct.get(params, "textDocument")
                let (uri, _) := sys.struct.get(doc, "uri")

                current_doc_text := text
                tokens := lexer_tokenize(text)
                current_ast := parse_program(tokens)

                diagnostics := []
                collect_diagnostics(current_ast, diagnostics)
                send_notification("textDocument/publishDiagnostics", { uri: uri, diagnostics: diagnostics })

            } else if method == "textDocument/completion" {
                let (params, _) := sys.struct.get(msg, "params")
                res := handle_completion(params)
                send_response(id, res)
            } else if method == "textDocument/hover" {
                let (params, _) := sys.struct.get(msg, "params")
                res := handle_hover(params, current_ast)
                if res != 0 { send_response(id, res) }
                else { send_response(id, 0) } // Null
            } else if method == "textDocument/definition" {
                let (params, _) := sys.struct.get(msg, "params")
                res := handle_definition(params, current_ast)
                if res != 0 { send_response(id, res) }
                else { send_response(id, 0) }
            } else if method == "shutdown" {
                send_response(id, 0) // Null
            } else if method == "exit" {
                sys.exit(0)
            }
        }
    }
}
