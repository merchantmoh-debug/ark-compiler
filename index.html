<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ark Compiler ‚Äî Sovereign Computation</title>
    <meta name="description" content="Ark is a neuro-symbolic programming language with linear types, cryptographic governance, and a 100% Rust runtime.">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>‚ö°</text></svg>">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --bg: #0a0a0f;
            --surface: #111118;
            --surface2: #1a1a24;
            --border: #222233;
            --text: #e4e4ef;
            --text-dim: #666680;
            --accent: #00ff88;
            --accent2: #00ccff;
            --danger: #ff3355;
            --warn: #ffaa00;
        }

        body {
            background: var(--bg);
            color: var(--text);
            font-family: 'Inter', -apple-system, sans-serif;
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* ‚îÄ‚îÄ Header ‚îÄ‚îÄ */
        .header {
            text-align: center;
            padding: 40px 20px 20px;
        }
        .header h1 {
            font-size: 2.2rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--accent), var(--accent2));
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 8px;
        }
        .header p {
            color: var(--text-dim);
            font-size: 0.95rem;
            max-width: 600px;
            margin: 0 auto 16px;
        }
        .badges {
            display: flex;
            gap: 8px;
            justify-content: center;
            flex-wrap: wrap;
        }
        .badge {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 0.5px;
            text-transform: uppercase;
        }
        .badge-green { background: rgba(0, 255, 136, 0.12); color: var(--accent); border: 1px solid rgba(0, 255, 136, 0.2); }
        .badge-blue { background: rgba(0, 204, 255, 0.12); color: var(--accent2); border: 1px solid rgba(0, 204, 255, 0.2); }
        .badge-red { background: rgba(255, 51, 85, 0.12); color: var(--danger); border: 1px solid rgba(255, 51, 85, 0.2); }

        /* ‚îÄ‚îÄ Main Layout ‚îÄ‚îÄ */
        .main {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 24px;
            max-width: 1100px;
            margin: 0 auto;
            padding: 20px;
        }
        @media (max-width: 768px) {
            .main { grid-template-columns: 1fr; }
        }

        /* ‚îÄ‚îÄ Card ‚îÄ‚îÄ */
        .card {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            overflow: hidden;
        }
        .card-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 16px;
            border-bottom: 1px solid var(--border);
            background: var(--surface2);
        }
        .card-header h2 {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text);
        }
        .card-body {
            padding: 16px;
        }

        /* ‚îÄ‚îÄ Snake Game ‚îÄ‚îÄ */
        .game-wrap {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        canvas {
            border: 1px solid var(--border);
            border-radius: 4px;
            background: #000;
            width: 100%;
            max-width: 400px;
            aspect-ratio: 1;
            image-rendering: pixelated;
        }
        .game-controls {
            display: flex;
            gap: 8px;
            margin-top: 12px;
        }
        .btn {
            background: var(--surface2);
            color: var(--text-dim);
            border: 1px solid var(--border);
            padding: 6px 14px;
            border-radius: 4px;
            font-family: 'Inter', sans-serif;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.15s;
        }
        .btn:hover {
            background: var(--border);
            color: var(--text);
            border-color: var(--accent);
        }
        .game-status {
            margin-top: 8px;
            font-size: 12px;
            color: var(--text-dim);
        }

        /* ‚îÄ‚îÄ Playground ‚îÄ‚îÄ */
        .playground-editor {
            width: 100%;
            min-height: 200px;
            background: #000;
            color: var(--accent);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 12px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px;
            line-height: 1.5;
            resize: vertical;
            outline: none;
        }
        .playground-editor:focus {
            border-color: var(--accent);
            box-shadow: 0 0 0 1px rgba(0, 255, 136, 0.2);
        }
        .playground-output {
            margin-top: 8px;
            background: #000;
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 12px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            color: var(--text-dim);
            min-height: 60px;
            max-height: 150px;
            overflow-y: auto;
        }
        .run-btn {
            background: rgba(0, 255, 136, 0.12);
            color: var(--accent);
            border: 1px solid rgba(0, 255, 136, 0.3);
        }
        .run-btn:hover {
            background: rgba(0, 255, 136, 0.25);
        }

        /* ‚îÄ‚îÄ Features ‚îÄ‚îÄ */
        .features {
            max-width: 1100px;
            margin: 40px auto;
            padding: 0 20px;
        }
        .features h2 {
            font-size: 1.3rem;
            margin-bottom: 20px;
            color: var(--text);
        }
        .feature-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 16px;
        }
        @media (max-width: 768px) {
            .feature-grid { grid-template-columns: 1fr; }
        }
        .feature {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 20px;
            transition: border-color 0.2s;
        }
        .feature:hover { border-color: var(--accent); }
        .feature h3 {
            font-size: 0.9rem;
            margin-bottom: 6px;
            color: var(--accent);
        }
        .feature p {
            font-size: 0.8rem;
            color: var(--text-dim);
            line-height: 1.5;
        }

        /* ‚îÄ‚îÄ Footer ‚îÄ‚îÄ */
        .footer {
            text-align: center;
            padding: 40px 20px;
            color: var(--text-dim);
            font-size: 11px;
            border-top: 1px solid var(--border);
            margin-top: 40px;
        }
        .footer a {
            color: var(--accent);
            text-decoration: none;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>‚ö° Ark Compiler</h1>
        <p>A neuro-symbolic programming language with linear types, cryptographic governance, and a 100% Rust runtime.</p>
        <div class="badges">
            <span class="badge badge-green">Rust Core</span>
            <span class="badge badge-blue">Linear Types</span>
            <span class="badge badge-red">AGPL v3</span>
            <span class="badge badge-green">100+ Tests Passing</span>
        </div>
    </div>

    <div class="main">
        <!-- Snake Game Card -->
        <div class="card">
            <div class="card-header">
                <h2>üêç Snake Game (Ark Demo)</h2>
                <span class="game-status" id="score">Score: 0</span>
            </div>
            <div class="card-body game-wrap">
                <canvas id="game" width="400" height="400"></canvas>
                <div class="game-controls">
                    <button class="btn" onclick="togglePause()">Pause (P)</button>
                    <button class="btn" onclick="restartGame()">Restart (R)</button>
                </div>
                <div class="game-status" id="status">Use Arrow Keys or WASD to play</div>
            </div>
        </div>

        <!-- Ark Playground Card -->
        <div class="card">
            <div class="card-header">
                <h2>üìù Ark Playground</h2>
                <button class="btn run-btn" onclick="runCode()">‚ñ∂ Run</button>
            </div>
            <div class="card-body">
                <textarea class="playground-editor" id="editor" spellcheck="false">// Ark ‚Äî Hello World
print("Hello from Ark!")

// Variables use :=
x := 42
name := "Sovereign"

// Functions
func greet(who) {
    return "Welcome, " + who + "!"
}

print(greet(name))
print("The answer is: " + x)

// Linear Types enforce resource safety
// let wallet := Wallet.create()
// send(wallet)  // wallet is MOVED, can't reuse
// print(wallet) // Compile Error: linear resource consumed</textarea>
                <div class="playground-output" id="output">// Output appears here...</div>
            </div>
        </div>
    </div>

    <!-- Features Section -->
    <div class="features">
        <h2>Architecture</h2>
        <div class="feature-grid">
            <div class="feature">
                <h3>100% Rust Core</h3>
                <p>106 intrinsics ported to native Rust. Crypto, networking, and filesystem run at native speed with memory safety.</p>
            </div>
            <div class="feature">
                <h3>Linear Type System</h3>
                <p>Resources (wallets, sockets, file handles) must be used exactly once. No GC, no leaks, no double-spend ‚Äî enforced at compile time.</p>
            </div>
            <div class="feature">
                <h3>Neuro-Symbolic Intrinsics</h3>
                <p>AI calls are first-class compiler intrinsics (sys.ask_ai), enabling caching, batching, and formal verification of outputs.</p>
            </div>
            <div class="feature">
                <h3>Cryptographic Governance</h3>
                <p>Built-in HMAC-signed execution receipts, Monotone Confidence gates, and Merkle audit trails for every computation step.</p>
            </div>
            <div class="feature">
                <h3>WASM Target</h3>
                <p>Compiles to WebAssembly. Run Ark programs in the browser with the full type checker and VM.</p>
            </div>
            <div class="feature">
                <h3>Self-Hosting Parser</h3>
                <p>A 1000+ line recursive descent parser written in Ark itself, proving the language's self-sufficiency.</p>
            </div>
        </div>
    </div>

    <div class="footer">
        <p>Ark Compiler v112.0 ‚Ä¢ <a href="https://github.com/merchantmoh-debug/ark-compiler">GitHub</a> ‚Ä¢ Dual Licensed: AGPL v3 / Commercial</p>
        <p style="margin-top: 4px;">¬© 2026 Mohamad Al-Zawahreh (Sovereign Systems)</p>
    </div>

    <script>
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // SNAKE GAME ‚Äî Pure JavaScript, guaranteed to work
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        const GRID = 20;
        const CELL = canvas.width / GRID;

        let snake, apple, dir, nextDir, score, gameOver, paused, loop_id;

        function initGame() {
            snake = [[10, 12], [10, 11], [10, 10]];
            apple = [5, 5];
            dir = [0, -1]; // up
            nextDir = [0, -1];
            score = 0;
            gameOver = false;
            paused = false;
            document.getElementById('score').textContent = 'Score: 0';
            document.getElementById('status').textContent = 'Use Arrow Keys or WASD to play';
        }

        function spawnApple() {
            let pos;
            do {
                pos = [Math.floor(Math.random() * GRID), Math.floor(Math.random() * GRID)];
            } while (snake.some(s => s[0] === pos[0] && s[1] === pos[1]));
            apple = pos;
        }

        function update() {
            if (gameOver || paused) return;

            dir = nextDir;
            const head = [snake[snake.length - 1][0] + dir[0], snake[snake.length - 1][1] + dir[1]];

            // Wall collision
            if (head[0] < 0 || head[0] >= GRID || head[1] < 0 || head[1] >= GRID) {
                gameOver = true;
                document.getElementById('status').textContent = 'Game Over ‚Äî Wall collision. Press R to restart.';
                return;
            }

            // Self collision
            if (snake.some(s => s[0] === head[0] && s[1] === head[1])) {
                gameOver = true;
                document.getElementById('status').textContent = 'Game Over ‚Äî Self collision. Press R to restart.';
                return;
            }

            snake.push(head);

            // Eat apple
            if (head[0] === apple[0] && head[1] === apple[1]) {
                score++;
                document.getElementById('score').textContent = `Score: ${score}`;
                spawnApple();
            } else {
                snake.shift();
            }
        }

        function draw() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Grid lines (subtle)
            ctx.strokeStyle = '#0a0a12';
            ctx.lineWidth = 0.5;
            for (let i = 0; i <= GRID; i++) {
                ctx.beginPath();
                ctx.moveTo(i * CELL, 0);
                ctx.lineTo(i * CELL, canvas.height);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(0, i * CELL);
                ctx.lineTo(canvas.width, i * CELL);
                ctx.stroke();
            }

            // Snake body
            for (let i = 0; i < snake.length; i++) {
                const [x, y] = snake[i];
                if (i === snake.length - 1) {
                    // Head
                    const grad = ctx.createLinearGradient(x * CELL, y * CELL, (x + 1) * CELL, (y + 1) * CELL);
                    grad.addColorStop(0, '#00ff88');
                    grad.addColorStop(1, '#00cc66');
                    ctx.fillStyle = grad;
                } else {
                    const t = i / snake.length;
                    ctx.fillStyle = `hsl(150, ${60 + t * 40}%, ${25 + t * 20}%)`;
                }
                ctx.fillRect(x * CELL + 1, y * CELL + 1, CELL - 2, CELL - 2);
            }

            // Apple
            ctx.fillStyle = '#ff3355';
            ctx.beginPath();
            ctx.arc(apple[0] * CELL + CELL / 2, apple[1] * CELL + CELL / 2, CELL / 2 - 2, 0, Math.PI * 2);
            ctx.fill();

            // Game over overlay
            if (gameOver) {
                ctx.fillStyle = 'rgba(10, 10, 15, 0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#ff3355';
                ctx.font = 'bold 28px Inter, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2 - 10);
                ctx.fillStyle = '#666';
                ctx.font = '14px Inter, sans-serif';
                ctx.fillText(`Score: ${score}  ‚Ä¢  Press R`, canvas.width / 2, canvas.height / 2 + 20);
                ctx.textAlign = 'start';
            }

            // Pause overlay
            if (paused && !gameOver) {
                ctx.fillStyle = 'rgba(10, 10, 15, 0.5)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#00ccff';
                ctx.font = 'bold 24px Inter, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('PAUSED', canvas.width / 2, canvas.height / 2);
                ctx.textAlign = 'start';
            }
        }

        function gameLoop() {
            update();
            draw();
        }

        function togglePause() {
            if (gameOver) return;
            paused = !paused;
            document.getElementById('status').textContent = paused ? 'Paused ‚Äî Press P to resume' : 'Playing';
        }

        function restartGame() {
            initGame();
            spawnApple();
        }

        // Input
        const KEY_MAP = {
            'ArrowUp': [0, -1], 'w': [0, -1],
            'ArrowDown': [0, 1], 's': [0, 1],
            'ArrowLeft': [-1, 0], 'a': [-1, 0],
            'ArrowRight': [1, 0], 'd': [1, 0],
        };

        document.addEventListener('keydown', e => {
            const k = e.key.length === 1 ? e.key.toLowerCase() : e.key;
            if (KEY_MAP[k]) {
                const nd = KEY_MAP[k];
                // Prevent 180-degree turns
                if (nd[0] !== -dir[0] || nd[1] !== -dir[1]) {
                    nextDir = nd;
                }
                e.preventDefault();
            }
            if (k === 'p') togglePause();
            if (k === 'r') restartGame();
        });

        // Start
        initGame();
        spawnApple();
        setInterval(gameLoop, 120);

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // ARK PLAYGROUND ‚Äî Client-side Ark interpreter (subset)
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        function runCode() {
            const code = document.getElementById('editor').value;
            const outputEl = document.getElementById('output');
            const lines = [];

            try {
                // Mini Ark interpreter ‚Äî handles the subset shown in the editor
                const env = {};
                const funcs = {};

                const tokens = code.split('\n');
                let i = 0;

                function evalExpr(expr) {
                    expr = expr.trim();
                    // String literal
                    if (expr.startsWith('"') && expr.endsWith('"')) {
                        return expr.slice(1, -1);
                    }
                    // Number
                    if (!Number.isNaN(Number(expr)) && expr !== '') {
                        return Number(expr);
                    }
                    // Function call
                    const callMatch = expr.match(/^(\w+)\((.+)\)$/);
                    if (callMatch) {
                        const fname = callMatch[1];
                        const argStr = callMatch[2];
                        if (funcs[fname]) {
                            const argVal = evalExpr(argStr);
                            const fenv = { ...env };
                            fenv[funcs[fname].param] = argVal;
                            return evalBody(funcs[fname].body, fenv);
                        }
                    }
                    // String concatenation
                    if (expr.includes(' + ')) {
                        const parts = expr.split(' + ');
                        return parts.map(p => String(evalExprInEnv(p.trim(), env))).join('');
                    }
                    // Variable lookup
                    if (env[expr] !== undefined) return env[expr];
                    return expr;
                }

                function evalExprInEnv(expr, localEnv) {
                    expr = expr.trim();
                    if (expr.startsWith('"') && expr.endsWith('"')) return expr.slice(1, -1);
                    if (!Number.isNaN(Number(expr)) && expr !== '') return Number(expr);
                    if (localEnv[expr] !== undefined) return localEnv[expr];
                    return expr;
                }

                function evalBody(bodyLines, localEnv) {
                    for (const line of bodyLines) {
                        const trimmed = line.trim();
                        if (trimmed.startsWith('return ')) {
                            const retExpr = trimmed.slice(7);
                            // Handle concatenation with local env
                            if (retExpr.includes(' + ')) {
                                const parts = retExpr.split(' + ');
                                return parts.map(p => {
                                    const pt = p.trim();
                                    if (pt.startsWith('"') && pt.endsWith('"')) return pt.slice(1, -1);
                                    if (localEnv[pt] !== undefined) return String(localEnv[pt]);
                                    if (env[pt] !== undefined) return String(env[pt]);
                                    return pt;
                                }).join('');
                            }
                            return evalExprInEnv(retExpr, localEnv);
                        }
                    }
                    return null;
                }

                while (i < tokens.length) {
                    let line = tokens[i].trim();
                    i++;

                    // Skip comments and blank lines
                    if (!line || line.startsWith('//')) continue;

                    // print()
                    const printMatch = line.match(/^print\((.+)\)$/);
                    if (printMatch) {
                        const arg = printMatch[1];
                        const val = evalExpr(arg);
                        lines.push(String(val));
                        continue;
                    }

                    // Variable assignment: x := value
                    const assignMatch = line.match(/^(\w+)\s*:=\s*(.+)$/);
                    if (assignMatch) {
                        env[assignMatch[1]] = evalExpr(assignMatch[2]);
                        continue;
                    }

                    // Function definition (simple)
                    const funcMatch = line.match(/^func\s+(\w+)\((\w+)\)\s*\{$/);
                    if (funcMatch) {
                        const fname = funcMatch[1];
                        const param = funcMatch[2];
                        const body = [];
                        while (i < tokens.length) {
                            const fl = tokens[i].trim();
                            i++;
                            if (fl === '}') break;
                            body.push(fl);
                        }
                        funcs[fname] = { param, body };
                        continue;
                    }

                    // let keyword (skip for playground)
                    if (line.startsWith('let ')) continue;
                }

                outputEl.textContent = lines.length > 0 ? lines.join('\n') : '// (no output)';
                outputEl.style.color = '#00ff88';
            } catch (err) {
                outputEl.textContent = `Error: ${err.message}`;
                outputEl.style.color = '#ff3355';
            }
        }
    </script>
</body>
</html>
