<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ark Compiler ‚Äî Sovereign Computation</title>
    <meta name="description" content="Ark is a neuro-symbolic programming language with linear types, cryptographic governance, and a 100% Rust runtime.">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>‚ö°</text></svg>">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --bg: #0a0a0f;
            --surface: #111118;
            --surface2: #1a1a24;
            --border: #222233;
            --text: #e4e4ef;
            --text-dim: #666680;
            --accent: #00ff88;
            --accent2: #00ccff;
            --danger: #ff3355;
            --warn: #ffaa00;
        }

        body {
            background: var(--bg);
            color: var(--text);
            font-family: 'Inter', -apple-system, sans-serif;
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* ‚îÄ‚îÄ Header ‚îÄ‚îÄ */
        .header {
            text-align: center;
            padding: 40px 20px 20px;
        }
        .header h1 {
            font-size: 2.2rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--accent), var(--accent2));
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 8px;
        }
        .header p {
            color: var(--text-dim);
            font-size: 0.95rem;
            max-width: 600px;
            margin: 0 auto 16px;
        }
        .badges {
            display: flex;
            gap: 8px;
            justify-content: center;
            flex-wrap: wrap;
        }
        .badge {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 0.5px;
            text-transform: uppercase;
        }
        .badge-green { background: rgba(0, 255, 136, 0.12); color: var(--accent); border: 1px solid rgba(0, 255, 136, 0.2); }
        .badge-blue { background: rgba(0, 204, 255, 0.12); color: var(--accent2); border: 1px solid rgba(0, 204, 255, 0.2); }
        .badge-red { background: rgba(255, 51, 85, 0.12); color: var(--danger); border: 1px solid rgba(255, 51, 85, 0.2); }

        /* ‚îÄ‚îÄ Main Layout ‚îÄ‚îÄ */
        .main {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 24px;
            max-width: 1100px;
            margin: 0 auto;
            padding: 20px;
        }
        @media (max-width: 768px) {
            .main { grid-template-columns: 1fr; }
        }

        /* ‚îÄ‚îÄ Card ‚îÄ‚îÄ */
        .card {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            overflow: hidden;
        }
        .card-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 16px;
            border-bottom: 1px solid var(--border);
            background: var(--surface2);
        }
        .card-header h2 {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text);
        }
        .card-body {
            padding: 16px;
        }

        /* ‚îÄ‚îÄ Snake Game ‚îÄ‚îÄ */
        .game-wrap {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        canvas {
            border: 1px solid var(--border);
            border-radius: 4px;
            background: #000;
            width: 100%;
            max-width: 400px;
            aspect-ratio: 1;
            image-rendering: pixelated;
        }
        .game-controls {
            display: flex;
            gap: 8px;
            margin-top: 12px;
        }
        .btn {
            background: var(--surface2);
            color: var(--text-dim);
            border: 1px solid var(--border);
            padding: 6px 14px;
            border-radius: 4px;
            font-family: 'Inter', sans-serif;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.15s;
        }
        .btn:hover {
            background: var(--border);
            color: var(--text);
            border-color: var(--accent);
        }
        .game-status {
            margin-top: 8px;
            font-size: 12px;
            color: var(--text-dim);
        }

        /* ‚îÄ‚îÄ Playground ‚îÄ‚îÄ */
        .playground-editor {
            width: 100%;
            min-height: 200px;
            background: #000;
            color: var(--accent);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 12px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px;
            line-height: 1.5;
            resize: vertical;
            outline: none;
        }
        .playground-editor:focus {
            border-color: var(--accent);
            box-shadow: 0 0 0 1px rgba(0, 255, 136, 0.2);
        }
        .playground-output {
            margin-top: 8px;
            background: #000;
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 12px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            color: var(--text-dim);
            min-height: 60px;
            max-height: 150px;
            overflow-y: auto;
        }
        .run-btn {
            background: rgba(0, 255, 136, 0.12);
            color: var(--accent);
            border: 1px solid rgba(0, 255, 136, 0.3);
        }
        .run-btn:hover {
            background: rgba(0, 255, 136, 0.25);
        }

        /* ‚îÄ‚îÄ Features ‚îÄ‚îÄ */
        .features {
            max-width: 1100px;
            margin: 40px auto;
            padding: 0 20px;
        }
        .features h2 {
            font-size: 1.3rem;
            margin-bottom: 20px;
            color: var(--text);
        }
        .feature-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 16px;
        }
        @media (max-width: 768px) {
            .feature-grid { grid-template-columns: 1fr; }
        }
        .feature {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 20px;
            transition: border-color 0.2s;
        }
        .feature:hover { border-color: var(--accent); }
        .feature h3 {
            font-size: 0.9rem;
            margin-bottom: 6px;
            color: var(--accent);
        }
        .feature p {
            font-size: 0.8rem;
            color: var(--text-dim);
            line-height: 1.5;
        }

        /* ‚îÄ‚îÄ Footer ‚îÄ‚îÄ */
        .footer {
            text-align: center;
            padding: 40px 20px;
            color: var(--text-dim);
            font-size: 11px;
            border-top: 1px solid var(--border);
            margin-top: 40px;
        }
        .footer a {
            color: var(--accent);
            text-decoration: none;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>‚ö° Ark Compiler</h1>
        <p>A neuro-symbolic programming language with linear types, cryptographic governance, and a 100% Rust runtime.</p>
        <div class="badges">
            <span class="badge badge-green">Rust Core</span>
            <span class="badge badge-blue">Linear Types</span>
            <span class="badge badge-red">AGPL v3</span>
            <span class="badge badge-green">100+ Tests Passing</span>
        </div>
    </div>

    <div class="main">
        <!-- Snake Game Card ‚Äî Powered by Ark -->
        <div class="card">
            <div class="card-header">
                <h2>üêç Snake Game <span style="font-size:0.65em;color:var(--accent);font-weight:400;">(Running snake_browser.ark)</span></h2>
                <span class="game-status" id="score">Score: 0</span>
            </div>
            <div class="card-body game-wrap">
                <canvas id="game" width="400" height="400"></canvas>
                <div class="game-controls">
                    <button class="btn" onclick="togglePause()">Pause (P)</button>
                    <button class="btn" onclick="restartGame()">Restart (R)</button>
                    <button class="btn" onclick="toggleArkSource()" style="margin-left:8px;" id="btn-src">View Ark Source</button>
                </div>
                <div class="game-status" id="status">Loading Ark runtime...</div>
                <pre id="ark-source" style="display:none;background:#0d0d14;border:1px solid #1a1a2e;border-radius:6px;padding:12px;margin-top:10px;max-height:320px;overflow-y:auto;font-size:12px;color:#8af;text-align:left;white-space:pre;tab-size:4;"></pre>
            </div>
        </div>

        <!-- Ark Playground Card -->
        <div class="card">
            <div class="card-header">
                <h2>üìù Ark Playground</h2>
                <button class="btn run-btn" onclick="runCode()">‚ñ∂ Run</button>
            </div>
            <div class="card-body">
                <textarea class="playground-editor" id="editor" spellcheck="false">// Ark ‚Äî Hello World
print("Hello from Ark!")

// Variables use :=
x := 42
name := "Sovereign"

// Functions
func greet(who) {
    return "Welcome, " + who + "!"
}

print(greet(name))
print("The answer is: " + x)

// Linear Types enforce resource safety
// let wallet := Wallet.create()
// send(wallet)  // wallet is MOVED, can't reuse
// print(wallet) // Compile Error: linear resource consumed</textarea>
                <div class="playground-output" id="output">// Output appears here...</div>
            </div>
        </div>
    </div>

    <!-- Features Section -->
    <div class="features">
        <h2>Architecture</h2>
        <div class="feature-grid">
            <div class="feature">
                <h3>100% Rust Core</h3>
                <p>106 intrinsics ported to native Rust. Crypto, networking, and filesystem run at native speed with memory safety.</p>
            </div>
            <div class="feature">
                <h3>Linear Type System</h3>
                <p>Resources (wallets, sockets, file handles) must be used exactly once. No GC, no leaks, no double-spend ‚Äî enforced at compile time.</p>
            </div>
            <div class="feature">
                <h3>Neuro-Symbolic Intrinsics</h3>
                <p>AI calls are first-class compiler intrinsics (sys.ask_ai), enabling caching, batching, and formal verification of outputs.</p>
            </div>
            <div class="feature">
                <h3>Cryptographic Governance</h3>
                <p>Built-in HMAC-signed execution receipts, Monotone Confidence gates, and Merkle audit trails for every computation step.</p>
            </div>
            <div class="feature">
                <h3>WASM Target</h3>
                <p>Compiles to WebAssembly. Run Ark programs in the browser with the full type checker and VM.</p>
            </div>
            <div class="feature">
                <h3>Self-Hosting Parser</h3>
                <p>A 1000+ line recursive descent parser written in Ark itself, proving the language's self-sufficiency.</p>
            </div>
        </div>
    </div>

    <div class="footer">
        <p>Ark Compiler v112.0 ‚Ä¢ <a href="https://github.com/merchantmoh-debug/ark-compiler">GitHub</a> ‚Ä¢ Dual Licensed: AGPL v3 / Commercial</p>
        <p style="margin-top: 4px;">¬© 2026 Mohamad Al-Zawahreh (Sovereign Systems)</p>
    </div>

    <script>
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // SNAKE GAME ‚Äî Powered by Ark (snake_browser.ark ‚Üí MAST ‚Üí eval)
        // The game logic is 100% Ark. This evaluator executes the AST
        // output by the Ark Rust parser. JS only renders to canvas.
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        const GRID = 20;
        const CELL = canvas.width / GRID;

        // ‚îÄ‚îÄ Ark MAST Evaluator ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // A faithful tree-walking interpreter for the Ark AST format.
        // Handles: Block, Function, Let, LetDestructure, If, While,
        //          Return, SetField, Expression, Variable, Literal,
        //          Call, GetField, List, StructInit + all intrinsics.

        class ReturnSignal { constructor(v) { this.value = v; } }

        const INTRINSICS = {
            'intrinsic_add': (a, b) => toNum(a) + toNum(b),
            'intrinsic_sub': (a, b) => toNum(a) - toNum(b),
            'intrinsic_mul': (a, b) => toNum(a) * toNum(b),
            'intrinsic_mod': (a, b) => { const B = toNum(b); return B === 0 ? 0 : ((toNum(a) % B) + B) % B; },
            'intrinsic_eq':  (a, b) => { if (typeof a === 'string' || typeof b === 'string') return String(a) === String(b) ? 1 : 0; return toNum(a) === toNum(b) ? 1 : 0; },
            'intrinsic_ne':  (a, b) => { if (typeof a === 'string' || typeof b === 'string') return String(a) !== String(b) ? 1 : 0; return toNum(a) !== toNum(b) ? 1 : 0; },
            'intrinsic_lt':  (a, b) => toNum(a) < toNum(b) ? 1 : 0,
            'intrinsic_le':  (a, b) => toNum(a) <= toNum(b) ? 1 : 0,
            'intrinsic_gt':  (a, b) => toNum(a) > toNum(b) ? 1 : 0,
            'intrinsic_ge':  (a, b) => toNum(a) >= toNum(b) ? 1 : 0,
            'intrinsic_and': (a, b) => (isTruthy(a) && isTruthy(b)) ? 1 : 0,
            'intrinsic_or':  (a, b) => (isTruthy(a) || isTruthy(b)) ? 1 : 0,
            'intrinsic_not': (a) => isTruthy(a) ? 0 : 1,
            'add': (a, b) => toNum(a) + toNum(b),
            'sub': (a, b) => toNum(a) - toNum(b),
            'mul': (a, b) => toNum(a) * toNum(b),
            'sys.len': (list) => Array.isArray(list) ? [list.length, null] : [0, null],
            'sys.list.get': (list, idx) => Array.isArray(list) ? [list[toNum(idx)] ?? null, null] : [null, 'not a list'],
            'sys.list.append': (list, val) => { if (Array.isArray(list)) list.push(deepClone(val)); return null; },
            'print': (...args) => { console.log('[Ark]', ...args); return null; },
        };

        function toNum(v) { return typeof v === 'number' ? v : (typeof v === 'string' ? (Number(v) || 0) : (v ? 1 : 0)); }
        function isTruthy(v) { return v !== 0 && v !== null && v !== undefined && v !== '' && v !== false; }
        function deepClone(v) {
            if (Array.isArray(v)) return v.map(deepClone);
            if (v && typeof v === 'object') {
                const o = {}; for (const k in v) o[k] = deepClone(v[k]); return o;
            }
            return v;
        }

        function evalExpr(expr, scope) {
            if (expr === null || expr === undefined) return null;

            // Literal: "42" or "ArrowUp"
            if (typeof expr === 'string') return expr;
            if ('Literal' in expr) {
                const lit = expr.Literal;
                const n = Number(lit);
                return Number.isFinite(n) && lit !== '' ? n : lit;
            }
            // Variable
            if ('Variable' in expr) {
                const name = expr.Variable;
                for (let i = scope.length - 1; i >= 0; i--) {
                    if (name in scope[i]) return scope[i][name];
                }
                return null;
            }
            // List
            if ('List' in expr) return expr.List.map(e => evalExpr(e, scope));
            // StructInit
            if ('StructInit' in expr) {
                const obj = {};
                for (const [k, v] of expr.StructInit.fields) obj[k] = evalExpr(v, scope);
                return obj;
            }
            // GetField
            if ('GetField' in expr) {
                const obj = evalExpr(expr.GetField.obj, scope);
                return (obj && typeof obj === 'object') ? obj[expr.GetField.field] : null;
            }
            // Call (intrinsics + user functions)
            if ('Call' in expr) {
                const { function_hash, args } = expr.Call;
                const evArgs = args.map(a => evalExpr(a, scope));
                // Intrinsic?
                if (INTRINSICS[function_hash]) return INTRINSICS[function_hash](...evArgs);
                // User function
                for (let i = scope.length - 1; i >= 0; i--) {
                    if (scope[i]['__fn_' + function_hash]) {
                        const fn = scope[i]['__fn_' + function_hash];
                        const fnScope = [{}];
                        for (let j = 0; j < fn.params.length; j++) {
                            fnScope[0][fn.params[j]] = deepClone(evArgs[j]);
                        }
                        // Copy function defs into scope
                        for (let j = scope.length - 1; j >= 0; j--) {
                            for (const k in scope[j]) {
                                if (k.startsWith('__fn_') && !(k in fnScope[0])) fnScope[0][k] = scope[j][k];
                            }
                        }
                        const res = execBlock(fn.body, fnScope);
                        return (res instanceof ReturnSignal) ? res.value : res;
                    }
                }
                console.warn('[Ark] Unknown function:', function_hash);
                return null;
            }
            // Statement wrapper
            if ('Statement' in expr) return execStmt(expr, scope);
            console.warn('[Ark] Unknown expr:', Object.keys(expr));
            return null;
        }

        function setVar(scope, name, value) {
            for (let i = scope.length - 1; i >= 0; i--) {
                if (name in scope[i]) { scope[i][name] = value; return; }
            }
            scope[scope.length - 1][name] = value;
        }

        function execStmt(stmt, scope) {
            if (!stmt) return null;
            // Block
            if ('Block' in (stmt.Statement || stmt)) {
                const block = (stmt.Statement || stmt).Block;
                return execBlock(block, scope);
            }
            // Function definition
            if ('Function' in stmt) {
                const fn = stmt.Function;
                scope[scope.length - 1]['__fn_' + fn.name] = {
                    params: fn.inputs.map(i => i[0]),
                    body: fn.body.content ? [fn.body.content] : [fn.body],
                };
                return null;
            }
            // Let
            if ('Let' in stmt) {
                const { name, value } = stmt.Let;
                setVar(scope, name, evalExpr(value, scope));
                return null;
            }
            // LetDestructure ‚Äî Ark returns (value, error) tuples
            if ('LetDestructure' in stmt) {
                const { names, value } = stmt.LetDestructure;
                const result = evalExpr(value, scope);
                if (Array.isArray(result)) {
                    for (let i = 0; i < names.length; i++) {
                        if (names[i] !== '_') setVar(scope, names[i], result[i] ?? null);
                    }
                } else {
                    if (names[0] !== '_') setVar(scope, names[0], result);
                    if (names.length > 1 && names[1] !== '_') setVar(scope, names[1], null);
                }
                return null;
            }
            // If
            if ('If' in stmt) {
                const { condition, then_block, else_block } = stmt.If;
                if (isTruthy(evalExpr(condition, scope))) {
                    const r = execBlock(then_block, scope);
                    if (r instanceof ReturnSignal) return r;
                } else if (else_block) {
                    const r = execBlock(else_block, scope);
                    if (r instanceof ReturnSignal) return r;
                }
                return null;
            }
            // While
            if ('While' in stmt) {
                const { condition, body } = stmt.While;
                let safety = 0;
                while (isTruthy(evalExpr(condition, scope)) && safety++ < 10000) {
                    const r = execBlock(body, scope);
                    if (r instanceof ReturnSignal) return r;
                }
                return null;
            }
            // Return
            if ('Return' in stmt) return new ReturnSignal(evalExpr(stmt.Return, scope));
            // SetField
            if ('SetField' in stmt) {
                const { obj_name, field, value } = stmt.SetField;
                for (let i = scope.length - 1; i >= 0; i--) {
                    if (obj_name in scope[i] && typeof scope[i][obj_name] === 'object') {
                        scope[i][obj_name][field] = evalExpr(value, scope);
                        return null;
                    }
                }
                return null;
            }
            // Expression statement
            if ('Expression' in stmt) { evalExpr(stmt.Expression, scope); return null; }
            console.warn('[Ark] Unknown stmt:', Object.keys(stmt));
            return null;
        }

        function execBlock(stmts, scope) {
            // CRITICAL: Do NOT unwrap ReturnSignal here ‚Äî propagate it
            // upward so nested blocks (inside if/while/block) can signal
            // a return to the calling function. Only callArkFunction unwraps.
            const list = Array.isArray(stmts) ? stmts : [stmts];
            for (const stmt of list) {
                const r = execStmt(stmt, scope);
                if (r instanceof ReturnSignal) return r;
            }
            return null;
        }

        // ‚îÄ‚îÄ Ark Program Loader ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        let arkFunctions = {};

        function loadArkMAST(mast) {
            const scope = [{}];
            // Process top-level block to register functions
            const top = mast.Statement ? mast.Statement.Block : (mast.Block || [mast]);
            for (const stmt of top) {
                if (stmt.Function) {
                    const fn = stmt.Function;
                    arkFunctions[fn.name] = {
                        params: fn.inputs.map(i => i[0]),
                        body: fn.body.content ? [fn.body.content] : [fn.body],
                    };
                }
            }
        }

        function callArkFunction(name, args) {
            const fn = arkFunctions[name];
            if (!fn) throw new Error(`Ark function '${name}' not found`);
            const fnScope = [{}];
            for (let i = 0; i < fn.params.length; i++) {
                fnScope[0][fn.params[i]] = deepClone(args[i] ?? null);
            }
            // Register all functions in scope for potential recursion
            for (const [k, v] of Object.entries(arkFunctions)) {
                fnScope[0]['__fn_' + k] = v;
            }
            const result = execBlock(fn.body, fnScope);
            // Unwrap ReturnSignal at the top level (function call boundary)
            return (result instanceof ReturnSignal) ? result.value : result;
        }

        // ‚îÄ‚îÄ Game State & Loop ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        let gameState = null;
        let lastInput = 'None';
        let paused = false;

        function draw() {
            if (!gameState) return;
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Grid
            ctx.strokeStyle = '#0a0a12';
            ctx.lineWidth = 0.5;
            for (let i = 0; i <= GRID; i++) {
                ctx.beginPath(); ctx.moveTo(i * CELL, 0); ctx.lineTo(i * CELL, canvas.height); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(0, i * CELL); ctx.lineTo(canvas.width, i * CELL); ctx.stroke();
            }

            // Snake
            const snake = gameState.snake || [];
            for (let i = 0; i < snake.length; i++) {
                const [x, y] = snake[i];
                if (i === snake.length - 1) {
                    const g = ctx.createLinearGradient(x*CELL, y*CELL, (x+1)*CELL, (y+1)*CELL);
                    g.addColorStop(0, '#00ff88'); g.addColorStop(1, '#00cc66');
                    ctx.fillStyle = g;
                } else {
                    const t = i / snake.length;
                    ctx.fillStyle = `hsl(150, ${60+t*40}%, ${25+t*20}%)`;
                }
                ctx.fillRect(toNum(x)*CELL+1, toNum(y)*CELL+1, CELL-2, CELL-2);
            }

            // Apple
            const apple = gameState.apple || [0, 0];
            ctx.fillStyle = '#ff3355';
            ctx.beginPath();
            ctx.arc(toNum(apple[0])*CELL+CELL/2, toNum(apple[1])*CELL+CELL/2, CELL/2-2, 0, Math.PI*2);
            ctx.fill();

            // Score
            const score = toNum(gameState.score);
            document.getElementById('score').textContent = `Score: ${score}`;

            // Game Over
            if (isTruthy(gameState.game_over)) {
                ctx.fillStyle = 'rgba(10,10,15,0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#ff3355';
                ctx.font = 'bold 28px Inter, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('GAME OVER', canvas.width/2, canvas.height/2-10);
                ctx.fillStyle = '#666';
                ctx.font = '14px Inter, sans-serif';
                ctx.fillText(`Score: ${score}  ‚Ä¢  Press R`, canvas.width/2, canvas.height/2+20);
                ctx.textAlign = 'start';
            }

            // Pause
            if (paused && !isTruthy(gameState.game_over)) {
                ctx.fillStyle = 'rgba(10,10,15,0.5)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#00ccff';
                ctx.font = 'bold 24px Inter, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('PAUSED', canvas.width/2, canvas.height/2);
                ctx.textAlign = 'start';
            }
        }

        function gameLoop() {
            if (!gameState) return;
            if (!paused && !isTruthy(gameState.game_over)) {
                try {
                    gameState = callArkFunction('update', [gameState, lastInput]);
                } catch (e) {
                    console.error('[Ark Runtime Error]', e);
                    document.getElementById('status').textContent = `Ark Error: ${e.message}`;
                }
            }
            draw();
        }

        function togglePause() {
            if (!gameState || isTruthy(gameState.game_over)) return;
            paused = !paused;
            document.getElementById('status').textContent = paused ? 'Paused ‚Äî Press P to resume' : 'Running snake_browser.ark';
        }

        function restartGame() {
            if (!arkFunctions.init) return;
            try {
                gameState = callArkFunction('init', []);
                lastInput = 'None';
                paused = false;
                document.getElementById('status').textContent = 'Running snake_browser.ark';
            } catch (e) {
                console.error('[Ark Init Error]', e);
            }
        }

        function toggleArkSource() {
            const el = document.getElementById('ark-source');
            const btn = document.getElementById('btn-src');
            if (el.style.display === 'none') {
                el.style.display = 'block';
                btn.textContent = 'Hide Ark Source';
            } else {
                el.style.display = 'none';
                btn.textContent = 'View Ark Source';
            }
        }

        // Input
        const WASD = { 'w': 'ArrowUp', 'a': 'ArrowLeft', 's': 'ArrowDown', 'd': 'ArrowRight' };
        document.addEventListener('keydown', e => {
            const k = e.key;
            const kl = k.toLowerCase();
            if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(k)) {
                if (!paused) lastInput = k;
                e.preventDefault();
            }
            if (WASD[kl]) { if (!paused) lastInput = WASD[kl]; e.preventDefault(); }
            if (kl === 'p') togglePause();
            if (kl === 'r') restartGame();
        });

        // ‚îÄ‚îÄ Boot: Load Ark MAST + Source ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        (async function boot() {
            const status = document.getElementById('status');
            try {
                // 1. Load the MAST (compiled AST from Ark parser)
                status.textContent = 'Loading Ark MAST...';
                const mastResp = await fetch('site/snake.json');
                if (!mastResp.ok) throw new Error(`MAST fetch failed: ${mastResp.status}`);
                const mast = await mastResp.json();

                // 2. Load and register functions
                loadArkMAST(mast);
                if (!arkFunctions.init || !arkFunctions.update) {
                    throw new Error('MAST missing init/update functions');
                }

                // 3. Call Ark init() ‚Äî runs through the evaluator
                gameState = callArkFunction('init', []);
                status.textContent = 'Running snake_browser.ark ‚Äî Use Arrow Keys or WASD';

                // 4. Load Ark source for display
                try {
                    const srcResp = await fetch('apps/snake_browser.ark');
                    if (srcResp.ok) {
                        document.getElementById('ark-source').textContent = await srcResp.text();
                    }
                } catch (_) { /* source display is optional */ }

                // 5. Start game loop
                setInterval(gameLoop, 120);
                draw();

            } catch (e) {
                status.textContent = `Ark Load Error: ${e.message}`;
                console.error('[Ark Boot]', e);
            }
        })();

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // ARK PLAYGROUND ‚Äî Client-side Ark interpreter (subset)
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        function runCode() {
            const code = document.getElementById('editor').value;
            const outputEl = document.getElementById('output');
            const lines = [];

            try {
                // Mini Ark interpreter ‚Äî handles the subset shown in the editor
                const env = {};
                const funcs = {};

                const tokens = code.split('\n');
                let i = 0;

                function evalExpr(expr) {
                    expr = expr.trim();
                    // String literal
                    if (expr.startsWith('"') && expr.endsWith('"')) {
                        return expr.slice(1, -1);
                    }
                    // Number
                    if (!Number.isNaN(Number(expr)) && expr !== '') {
                        return Number(expr);
                    }
                    // Function call
                    const callMatch = expr.match(/^(\w+)\((.+)\)$/);
                    if (callMatch) {
                        const fname = callMatch[1];
                        const argStr = callMatch[2];
                        if (funcs[fname]) {
                            const argVal = evalExpr(argStr);
                            const fenv = { ...env };
                            fenv[funcs[fname].param] = argVal;
                            return evalBody(funcs[fname].body, fenv);
                        }
                    }
                    // String concatenation
                    if (expr.includes(' + ')) {
                        const parts = expr.split(' + ');
                        return parts.map(p => String(evalExprInEnv(p.trim(), env))).join('');
                    }
                    // Variable lookup
                    if (env[expr] !== undefined) return env[expr];
                    return expr;
                }

                function evalExprInEnv(expr, localEnv) {
                    expr = expr.trim();
                    if (expr.startsWith('"') && expr.endsWith('"')) return expr.slice(1, -1);
                    if (!Number.isNaN(Number(expr)) && expr !== '') return Number(expr);
                    if (localEnv[expr] !== undefined) return localEnv[expr];
                    return expr;
                }

                function evalBody(bodyLines, localEnv) {
                    for (const line of bodyLines) {
                        const trimmed = line.trim();
                        if (trimmed.startsWith('return ')) {
                            const retExpr = trimmed.slice(7);
                            // Handle concatenation with local env
                            if (retExpr.includes(' + ')) {
                                const parts = retExpr.split(' + ');
                                return parts.map(p => {
                                    const pt = p.trim();
                                    if (pt.startsWith('"') && pt.endsWith('"')) return pt.slice(1, -1);
                                    if (localEnv[pt] !== undefined) return String(localEnv[pt]);
                                    if (env[pt] !== undefined) return String(env[pt]);
                                    return pt;
                                }).join('');
                            }
                            return evalExprInEnv(retExpr, localEnv);
                        }
                    }
                    return null;
                }

                while (i < tokens.length) {
                    let line = tokens[i].trim();
                    i++;

                    // Skip comments and blank lines
                    if (!line || line.startsWith('//')) continue;

                    // print()
                    const printMatch = line.match(/^print\((.+)\)$/);
                    if (printMatch) {
                        const arg = printMatch[1];
                        const val = evalExpr(arg);
                        lines.push(String(val));
                        continue;
                    }

                    // Variable assignment: x := value
                    const assignMatch = line.match(/^(\w+)\s*:=\s*(.+)$/);
                    if (assignMatch) {
                        env[assignMatch[1]] = evalExpr(assignMatch[2]);
                        continue;
                    }

                    // Function definition (simple)
                    const funcMatch = line.match(/^func\s+(\w+)\((\w+)\)\s*\{$/);
                    if (funcMatch) {
                        const fname = funcMatch[1];
                        const param = funcMatch[2];
                        const body = [];
                        while (i < tokens.length) {
                            const fl = tokens[i].trim();
                            i++;
                            if (fl === '}') break;
                            body.push(fl);
                        }
                        funcs[fname] = { param, body };
                        continue;
                    }

                    // let keyword (skip for playground)
                    if (line.startsWith('let ')) continue;
                }

                outputEl.textContent = lines.length > 0 ? lines.join('\n') : '// (no output)';
                outputEl.style.color = '#00ff88';
            } catch (err) {
                outputEl.textContent = `Error: ${err.message}`;
                outputEl.style.color = '#ff3355';
            }
        }
    </script>
</body>
</html>
